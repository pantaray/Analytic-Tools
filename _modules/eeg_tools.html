<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>eeg_tools</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/myaddon.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          Analytic Tools Documentation</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://www.masseyeandear.org/research/otolaryngology/investigators/laboratories/simonyanlab">Dystonia and Motor Control Laboratory</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Browse <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.degrees_und.html">nws_tools.degrees_und</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.strengths_und.html">nws_tools.strengths_und</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.density_und.html">nws_tools.density_und</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.get_corr.html">nws_tools.get_corr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.mutual_info.html">nws_tools.mutual_info</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.corrcheck.html">nws_tools.corrcheck</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.rm_negatives.html">nws_tools.rm_negatives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.rm_selfies.html">nws_tools.rm_selfies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.issym.html">nws_tools.issym</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.get_meannw.html">nws_tools.get_meannw</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.thresh_nws.html">nws_tools.thresh_nws</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.generate_randnws.html">nws_tools.generate_randnws</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.shownet.html">nws_tools.shownet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.show_nw.html">nws_tools.show_nw</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.csv2dict.html">nws_tools.csv2dict</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.normalize.html">nws_tools.normalize</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.nw_zip.html">nws_tools.nw_zip</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.hdfburp.html">nws_tools.hdfburp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.printdata.html">nws_tools.printdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/nws_tools.img2vid.html">nws_tools.img2vid</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/plotly_tools.cmap_plt2js.html">plotly_tools.cmap_plt2js</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/plotly_tools.make_brainsurf.html">plotly_tools.make_brainsurf</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/eeg_tools.read_eeg.html">eeg_tools.read_eeg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/eeg_tools.load_data.html">eeg_tools.load_data</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/eeg_tools.bandpass_filter.html">eeg_tools.bandpass_filter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/eeg_tools.MA.html">eeg_tools.MA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/eeg_tools.time2ind.html">eeg_tools.time2ind</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/stats_tools.perm_test.html">stats_tools.perm_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/stats_tools.printstats.html">stats_tools.printstats</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/recipes.natural_sort.html">recipes.natural_sort</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/recipes.regexfind.html">recipes.regexfind</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/recipes.query_yes_no.html">recipes.query_yes_no</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/recipes.myglob.html">recipes.myglob</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/recipes.get_numlines.html">recipes.get_numlines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/recipes.moveit.html">recipes.moveit</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/sim_tools.run_model.html">sim_tools.run_model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/sim_tools.make_bold.html">sim_tools.make_bold</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/sim_tools.plot_sim.html">sim_tools.plot_sim</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/sim_tools.show_params.html">sim_tools.show_params</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_stubs/sim_tools.make_D.html">sim_tools.make_D</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Navigate <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for eeg_tools</h1><div class="highlight"><pre>
<span></span><span class="c1"># eeg_tools.py - Toolset to read/write EEG data</span>
<span class="c1"># </span>
<span class="c1"># Author: Stefan Fuertinger [stefan.fuertinger@esi-frankfurt.de]</span>
<span class="c1"># Created: March 19 2014</span>
<span class="c1"># Last modified: &lt;2017-09-15 16:41:38&gt;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">calendar</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">psutil</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">buttord</span><span class="p">,</span> <span class="n">butter</span><span class="p">,</span> <span class="n">kaiserord</span><span class="p">,</span> <span class="n">kaiser</span><span class="p">,</span> <span class="n">lfilter</span><span class="p">,</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">firwin</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>

<span class="kn">from</span> <span class="nn">nws_tools</span> <span class="k">import</span> <span class="n">myglob</span>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="bandpass_filter"><a class="viewcode-back" href="../_stubs/eeg_tools.bandpass_filter.html#eeg_tools.bandpass_filter">[docs]</a><span class="k">def</span> <span class="nf">bandpass_filter</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span><span class="n">locut</span><span class="p">,</span><span class="n">hicut</span><span class="p">,</span><span class="n">srate</span><span class="p">,</span><span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">passdB</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">stopdB</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span><span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;IIR&#39;</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Band-/Low-/High-pass filter a 1D/2D input signal</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : NumPy 1d/2darray</span>
<span class="sd">        Input signal to be filtered. For 2d arrays it is assumed that `signal` has shape `M`-by-`N`, </span>
<span class="sd">        where `M` is the number of 1d signals (e.g., channels), and `N` is the number </span>
<span class="sd">        of samples (measurements etc.). </span>
<span class="sd">    locut : float</span>
<span class="sd">        Lower cutoff frequency in Hz. If `locut` is `None` then high-pass filtering </span>
<span class="sd">        is performed. </span>
<span class="sd">    hicut : float</span>
<span class="sd">        Upper cutoff frequency in Hz. If `hicut` is `None` then low-pass filtering </span>
<span class="sd">        is performed. </span>
<span class="sd">    srate : float </span>
<span class="sd">        Sampling rate of the signal in Hz.</span>
<span class="sd">    offset : float</span>
<span class="sd">        Offset frequency in Hz. The frequency shift used to calculate the stopband (see </span>
<span class="sd">        Notes for details). By default, the offset is a fraction of low-/high-cut </span>
<span class="sd">        frequencies. </span>
<span class="sd">    passdB : float</span>
<span class="sd">        Maximal frequency loss in the passband (in dB). For `ftype = FIR` (see below) </span>
<span class="sd">        `passdB` has to be equals `stopdB`.</span>
<span class="sd">    stopdB : float</span>
<span class="sd">        Minimal frequency attentuation in the stopband (in dB). For `ftype = FIR` (see below) </span>
<span class="sd">        `passdB` has to be equals `stopdB`.</span>
<span class="sd">    ftype : str</span>
<span class="sd">        Type of filter to be used (either `IIR` = infinite impulse response filter, or</span>
<span class="sd">        `FIR` = finite impulse response filter). </span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Boolean flag to decide whether status messages are printed or not. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    filtered : NumPy 1d/2darray</span>
<span class="sd">        Filtered version of input `signal`. </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This routine uses a Butterworth filter (for `ftype = &#39;IIR&#39;`) or a Kaiser filter</span>
<span class="sd">    (for `ftype = &#39;FIR&#39;`) to low-/high-/bandpass the input signal. </span>
<span class="sd">    Based on the user&#39;s input the optimal (i.e., lowest) order of the filter</span>
<span class="sd">    is calculated. Note that depending on the choice of cutoff frequencies and values </span>
<span class="sd">    of `passdB` and `stopdB` the computed filter coefficients might be very large/low </span>
<span class="sd">    causing numerical instability in the filtering routine. The code assumes you know</span>
<span class="sd">    what you&#39;re doing and does not try to guess whether the combination of </span>
<span class="sd">    cutoff-frequencies, offset and attenuation/amplification values applied to the </span>
<span class="sd">    input signal makes sense. </span>

<span class="sd">    By default the offset frequency is computed as fraction of the input frequencies, </span>
<span class="sd">    i.e., for low-/high-pass filters the offset is 0.5*cutoff-frequency, for band-pass</span>
<span class="sd">    filters the offset is calculated as 0.5 times the width of the pass-band. The following</span>
<span class="sd">    skteches illustrate the filter&#39;s operating modes</span>

<span class="sd">    :: </span>

<span class="sd">       Amplification </span>
<span class="sd">       (dB)</span>
<span class="sd">       / \\</span>
<span class="sd">       ||            Low-pass</span>
<span class="sd">       || ---------------------+</span>
<span class="sd">       ||                      |\\</span>
<span class="sd">       ||                      | \\</span>
<span class="sd">       ||                      |  +---------</span>
<span class="sd">       ||               PASS   |OS|   STOP</span>
<span class="sd">       || </span>
<span class="sd">       ++===================================&gt; Frequency (Hz)</span>


<span class="sd">       Amplification </span>
<span class="sd">       (dB)</span>
<span class="sd">       /\\</span>
<span class="sd">       ||            High-pass</span>
<span class="sd">       ||           +------------------------</span>
<span class="sd">       ||          /|	    </span>
<span class="sd">       ||         / |	    </span>
<span class="sd">       || -------+  |	    </span>
<span class="sd">       || STOP   |OS|   PASS  </span>
<span class="sd">       || </span>
<span class="sd">       ++===================================&gt; Frequency (Hz)</span>


<span class="sd">       Amplification </span>
<span class="sd">       (dB)</span>
<span class="sd">       /\\</span>
<span class="sd">       ||            Band-pass</span>
<span class="sd">       ||	    +----------+</span>
<span class="sd">       ||	   /|          |\\</span>
<span class="sd">       ||         / |	       | \\</span>
<span class="sd">       || -------+  |	       |  +---------</span>
<span class="sd">       || STOP   |OS|   PASS   |OS|   STOP</span>
<span class="sd">       ||</span>
<span class="sd">       ++===================================&gt; Frequency (Hz)</span>


<span class="sd">    Where `STOP` = stop-band, `OS` = offset, `PASS` = pass-band. </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    We construct an artifical signal which we want to low-/high-/band-pass filter. </span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; srate = 5000 # Sampling rate in Hz</span>
<span class="sd">    &gt;&gt;&gt; T = 0.05</span>
<span class="sd">    &gt;&gt;&gt; nsamples = T*srate</span>
<span class="sd">    &gt;&gt;&gt; t = np.linspace(0,T,nsamples,endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; a = 0.02</span>
<span class="sd">    &gt;&gt;&gt; f0 = 600.0</span>
<span class="sd">    &gt;&gt;&gt; signal = 0.1 * np.sin(2 * np.pi * 1.2 * np.sqrt(t))</span>
<span class="sd">    &gt;&gt;&gt; signal += 0.01 * np.cos(2 * np.pi * 312 * t + 0.1)</span>
<span class="sd">    &gt;&gt;&gt; signal += a * np.cos(2 * np.pi * f0 * t + .11)</span>
<span class="sd">    &gt;&gt;&gt; signal += 0.03 * np.cos(2 * np.pi * 2000 * t)</span>

<span class="sd">    First, we low-pass filter the signal using the default IIR Butterworth filter (all</span>
<span class="sd">    examples given below can be repeated using the FIR Kaiser filter by additionally </span>
<span class="sd">    providing the keyword argument `ftype=&#39;FIR&#39;`). </span>
<span class="sd">    As cutoff frequency we choose 50Hz, with an offset of 10Hz. That means frequencies </span>
<span class="sd">    [0-50] Hz &quot;survive&quot;, frequencies in the band [50-60] Hz are gradually attenuated, </span>
<span class="sd">    all frequencies &gt;60Hz are maximally attenuated.</span>

<span class="sd">    &gt;&gt;&gt; filtered = bandpass_filter(signal,50,None,5000,offset=10)</span>

<span class="sd">    Now, construct a high-pass filter that removes all frequencies below 500Hz, using</span>
<span class="sd">    the default offset of 0.5*`hicut` (see Notes for details). </span>

<span class="sd">    &gt;&gt;&gt; filtered = bandpass_filter(signal,None,500,5000)</span>

<span class="sd">    Finally, we band-pass filter the signal, so that only frequency components between</span>
<span class="sd">    500Hz and 1250Hz remain</span>

<span class="sd">    &gt;&gt;&gt; filtered = bandpass_filter(signal,500,1250,5000)</span>
<span class="sd">    </span>
<span class="sd">    Note that ill-chosen values for the offset (e.g., very steep slopes, from the </span>
<span class="sd">    stop- to the pass-band, see Notes for a sketch) and/or attenuation/amplification </span>
<span class="sd">    dB&#39;s may lead to very large/small filter coefficients that may cause erratic </span>
<span class="sd">    results due to numerical instability. </span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.signal.buttord : routine used to calculate optimal filter order</span>
<span class="sd">    scipy.signal.butter : routine used to construct Butterworth filter based on output of buttord. </span>
<span class="sd">    scipy.signal.lfilter : filters the input signal using calculated Butterworth filter design</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks: `signal`</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stu</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Signal must be a 1d/2d NumPy array, not &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Signal must be a 1d/2d NumPy array&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">stu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Signal only consists of one datapoint!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Signal must be a real-valued &#39;</span><span class="o">+</span><span class="n">dim_msg</span><span class="o">+</span><span class="s1">&#39; NumPy array!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Signal must be a real valued NumPy array without Infs or NaNs!&#39;</span><span class="p">)</span>

    <span class="c1"># Both cutoffs undefined</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">locut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">hicut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Both cutoff frequencies are `None`!&#39;</span><span class="p">)</span>

    <span class="c1"># Sampling rate</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">srate</span><span class="p">,</span><span class="s1">&#39;srate&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">srate</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sampling rate hast to be &gt; 0!&#39;</span><span class="p">)</span>

    <span class="c1"># Compute Nyquist frequency and initialize passfreq</span>
    <span class="n">nyq</span>      <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">srate</span> 
    <span class="n">passfreq</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Lower cutoff frequency</span>
    <span class="k">if</span> <span class="n">locut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">locut</span><span class="p">,</span><span class="s1">&#39;locut&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">passfreq</span> <span class="o">=</span> <span class="n">hicut</span><span class="o">/</span><span class="n">nyq</span>

    <span class="c1"># Higher cutoff frequency</span>
    <span class="k">if</span> <span class="n">hicut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">hicut</span><span class="p">,</span><span class="s1">&#39;hicut&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">passfreq</span> <span class="o">=</span> <span class="n">locut</span><span class="o">/</span><span class="n">nyq</span>

    <span class="c1"># Offset frequency for filter</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="s1">&#39;offset&#39;</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Frequency offset has to be &gt; 0!&#39;</span><span class="p">)</span>

        <span class="c1"># Adjust offset for Nyquist frequency</span>
        <span class="n">offset</span> <span class="o">/=</span> <span class="n">nyq</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Multiplicator for offset</span>
        <span class="n">offmult</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="c1"># If no offset frequency was provided, assign default value (for low-/high-pass filters)</span>
        <span class="k">if</span> <span class="n">passfreq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offmult</span><span class="o">*</span><span class="n">passfreq</span>

    <span class="c1"># Filter type</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ftype</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Filtertype has to be either &#39;FIR&#39; or &#39;IIR&#39;, not &quot;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">ftype</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ftype</span> <span class="o">!=</span> <span class="s1">&#39;IIR&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ftype</span> <span class="o">!=</span> <span class="s1">&#39;FIR&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Filtertype has to be either FIR or IIR!&#39;</span><span class="p">)</span>

    <span class="c1"># Passband decibel value</span>
    <span class="n">userpass</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">passdB</span><span class="p">,</span><span class="s1">&#39;passdB&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">passdB</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">passdB</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Passband dB has to be &gt; 0!&#39;</span><span class="p">)</span>
        <span class="n">userpass</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Stopband decibel value</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">stopdB</span><span class="p">,</span><span class="s1">&#39;stopdB&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stopdB</span> <span class="o">!=</span> <span class="mi">30</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">stopdB</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Stopband dB has to be &gt; 0!&#39;</span><span class="p">)</span>
        <span class="n">userpass</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Since the Kaiser filter requires max/min ripple to be equal, make sure that condition is satisfied</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;FIR&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">passdB</span> <span class="o">!=</span> <span class="n">stopdB</span><span class="p">:</span>

            <span class="c1"># Take the maximum of the two dB values</span>
            <span class="n">passdB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">passdB</span><span class="p">,</span><span class="n">stopdB</span><span class="p">])</span>
            <span class="n">stopdB</span> <span class="o">=</span> <span class="n">passdB</span>

            <span class="c1"># If the user supplied different dB values, print a warning</span>
            <span class="k">if</span> <span class="n">userpass</span><span class="p">:</span> 
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;WARNING: FIR filter requires stopdB = passdB, setting stopdB = passdB = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">passdB</span><span class="p">)</span>
                <span class="nb">print</span> <span class="n">msg</span>

    <span class="c1"># Determine if we do low-/high-/bandpass-filtering</span>
    <span class="k">if</span> <span class="n">locut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ftype</span>    <span class="o">=</span> <span class="s1">&#39;highpass&#39;</span>
        <span class="n">stopfreq</span> <span class="o">=</span> <span class="n">passfreq</span> <span class="o">-</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="n">stopfreq</span> <span class="o">&gt;</span> <span class="n">passfreq</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Highpass stopfrequency is higher than passfrequency!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">passfreq</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Highpass frequency &gt;= Nyquist frequency!&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">hicut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ftype</span>    <span class="o">=</span> <span class="s1">&#39;lowpass&#39;</span>
        <span class="n">stopfreq</span> <span class="o">=</span> <span class="n">passfreq</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="n">stopfreq</span> <span class="o">&lt;</span> <span class="n">passfreq</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lowpass stopfrequency is lower than passfrequency!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stopfreq</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lowpass stop frequency &gt;= Nyquist frequency!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ftype</span>    <span class="o">=</span> <span class="s1">&#39;bandpass&#39;</span>
        <span class="n">passfreq</span> <span class="o">=</span> <span class="p">[</span><span class="n">locut</span><span class="o">/</span><span class="n">nyq</span><span class="p">,</span><span class="n">hicut</span><span class="o">/</span><span class="n">nyq</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offmult</span><span class="o">*</span><span class="p">(</span><span class="n">passfreq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">passfreq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">stopfreq</span> <span class="o">=</span> <span class="p">[</span><span class="n">passfreq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">passfreq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stopfreq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">passfreq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">stopfreq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">passfreq</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Stopband is inside the passband!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stopfreq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Highpass frequency = Nyquist frequency!&#39;</span><span class="p">)</span>

    <span class="c1"># Check `verbose` flag</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The optional argument `verbose` has to be Boolean!&quot;</span><span class="p">)</span>
        
    <span class="c1"># Show input frequencies</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;Input frequency/frequencies: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">locut</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;Hz, &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">hicut</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;Hz&quot;</span>

    <span class="c1"># Compute optimal order of filter</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;IIR&#39;</span><span class="p">:</span>

        <span class="c1"># Compute optimal order of Butterworth filter</span>
        <span class="n">order</span><span class="p">,</span> <span class="n">natfreq</span> <span class="o">=</span> <span class="n">buttord</span><span class="p">(</span><span class="n">passfreq</span><span class="p">,</span> <span class="n">stopfreq</span><span class="p">,</span> <span class="n">passdB</span><span class="p">,</span> <span class="n">stopdB</span><span class="p">)</span>
        
        <span class="c1"># Show natural frequencies and optimal order of filter</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;Natural frequency/frequencies: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">natfreq</span><span class="o">*</span><span class="n">nyq</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;Hz&quot;</span>
            <span class="nb">print</span> <span class="s2">&quot;Optimal order for Butterworth filter was found to be: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="c1"># Compute Butterworth filter coefficients</span>
        <span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">natfreq</span><span class="p">,</span><span class="n">btype</span><span class="o">=</span><span class="n">ftype</span><span class="p">)</span>

        <span class="c1"># Filter data</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">signal</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Compute optimal order of Kaiser filter</span>
        <span class="n">order</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">kaiserord</span><span class="p">(</span><span class="n">passdB</span><span class="p">,</span><span class="n">offset</span><span class="p">)</span>

        <span class="c1"># Show optimal order</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;Optimal order for Kaiser filter was found to be: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="c1"># Compute Kaiser filter coefficients</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">passfreq</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;kaiser&#39;</span><span class="p">,</span><span class="n">beta</span><span class="p">),</span><span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Filter data</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,[</span><span class="mf">1.0</span><span class="p">],</span><span class="n">signal</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">filtered</span></div>

<span class="c1">##########################################################################################</span>
<span class="k">def</span> <span class="nf">bcd</span><span class="p">(</span><span class="n">int_in</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used internally by read_eeg to convert unsigned integers to binary format and back again</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">int_in</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0:08b}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">int_in</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">10</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">int_in</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">int_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:],</span><span class="mi">2</span><span class="p">)</span>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="read_eeg"><a class="viewcode-back" href="../_stubs/eeg_tools.read_eeg.html#eeg_tools.read_eeg">[docs]</a><span class="k">def</span> <span class="nf">read_eeg</span><span class="p">(</span><span class="n">eegpath</span><span class="p">,</span><span class="n">outfile</span><span class="p">,</span><span class="n">electrodelist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">savemat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read raw EEG data from binary `*.EEG/*.eeg` and `*.21E` files</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    eegpath : str</span>
<span class="sd">        Path to the *.EEG/*.eeg file (the code assumes that the corresponding *.21E/*.21e file is </span>
<span class="sd">        in the same location)</span>
<span class="sd">    outfile : str</span>
<span class="sd">        Path specifying the HDF5 file to be created. WARNING: File MUST NOT exist!</span>
<span class="sd">    electrodelist : list</span>
<span class="sd">        Python list of strings holding names of electrodes to be saved (if not the entire </span>
<span class="sd">        EEG file is needed/wanted). By default the entire EEG file is converted to HDF5. </span>
<span class="sd">    savemat : bool</span>
<span class="sd">        Specifiy if data should be saved as a NumPy 2darray (format is: number of electrodes by </span>
<span class="sd">        number of samples) or by electrodenames (see Examples for details)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing : None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Depending on the value of `savemat` the HDF5 file structure will differ. The HDF5 file always</span>
<span class="sd">    contain the groups `EEG`. In `EEG` the raw data is stored either as NumPy 2darray </span>
<span class="sd">    (`savemat = True`) or sorted by electrode name (`savemat = False`). Metadata of the EEG scan </span>
<span class="sd">    (record date, sampling rate, session length etc.) are stored as attributes of the `EEG` group. </span>
<span class="sd">    Note: The code allocates 25% of RAM available on the machine to temporarily hold the EEG data. </span>
<span class="sd">    Thus, reading/writing may take longer on computers with little memory. </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose the files `test.eeg` and `test.21E` are in the directory `mytest`. Suppose further </span>
<span class="sd">    that the EEG file contains recordings of 84 electrodes and the output HDF5 container </span>
<span class="sd">    should be `Results/test.h5`. If the entire EEG file has to be converted to HDF5 </span>
<span class="sd">    as a matrix then, `cd` to the parent directory of `mytest` and type</span>

<span class="sd">    &gt;&gt;&gt; read_eeg(&#39;mytest/test.eeg&#39;,&#39;Results/test.h5&#39;)</span>

<span class="sd">    The resulting HDF5 file contains the group `EEG` with attributes holding the corresponding metadata </span>
<span class="sd">    (see Notes for details). The EEG time-courses can be found in `EEG`:</span>

<span class="sd">    &gt;&gt;&gt; f = h5py.File(&#39;Results/test.h5&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f[&#39;EEG&#39;].keys()</span>
<span class="sd">    &gt;&gt;&gt; [&#39;eeg_mat&#39;]</span>
<span class="sd">    </span>
<span class="sd">    The dataset `eeg_mat` holds the entire EEG dataset as matrix (NumPy 2darray),  </span>

<span class="sd">    &gt;&gt;&gt; f[&#39;EEG&#39;][&#39;eeg_mat&#39;].value</span>
<span class="sd">    &gt;&gt;&gt; array([[32079, 32045, 32001, ..., 33607, 33556, 33530],</span>
<span class="sd">              [31708, 31712, 31712, ..., 33607, 33597, 33599],</span>
<span class="sd">              [31719, 31722, 31704, ..., 33733, 33713, 33708],</span>
<span class="sd">              ..., </span>
<span class="sd">              [39749, 34844, 36671, ..., 44616, 43642, 41030],</span>
<span class="sd">              [30206, 28126, 30805, ..., 39691, 36586, 34550],</span>
<span class="sd">              [31084, 30167, 31580, ..., 38113, 36470, 35205]], dtype=uint16)</span>

<span class="sd">    The attribute `electrode_list` is a NumPy array of electrodenames corresponding to the rows of `eeg_mat`, </span>
<span class="sd">    i.e., `f[&#39;EEG&#39;][&#39;eeg_mat&#39;][23,:]` is the time-series of electrode `f[&#39;EEG&#39;].attrs[&#39;electrode_list&#39;][23]`</span>

<span class="sd">    &gt;&gt;&gt; f[&#39;EEG&#39;].attrs[&#39;electrode_list&#39;][23]</span>
<span class="sd">    &gt;&gt;&gt; &#39;RFC8&#39;</span>
<span class="sd">    &gt;&gt;&gt; f[&#39;EEG&#39;][&#39;eeg_mat&#39;][23,:]</span>
<span class="sd">    &gt;&gt;&gt; array([33602, 33593, 33649, ..., 32626, 32648, 32650], dtype=uint16)</span>

<span class="sd">    Additional meta-data (like scanning date, session length, etc.) are also saved as group attributes</span>
<span class="sd">    where `summary` is a string representation of all meta values, i.e., </span>

<span class="sd">    &gt;&gt;&gt; f[&#39;EEG&#39;].attrs[&#39;summary&#39;]</span>
<span class="sd">    &gt;&gt;&gt;  Data was recorded on Friday, April 11 2014</span>
<span class="sd">         Begin of session: 10:1:49</span>
<span class="sd">         Sampling rate: 1000 Hz</span>
<span class="sd">         Length of session: 2.0 hours</span>

<span class="sd">    The respective meta values are stored as individual attributes (using numeric values), e.g., </span>

<span class="sd">    &gt;&gt;&gt; f[&#39;EEG&#39;].attrs[&#39;session_length&#39;]</span>
<span class="sd">    &gt;&gt;&gt; 2.0</span>

<span class="sd">    If only the electrodes &#39;RFA1&#39; and &#39;RFA3&#39; are of interest and the read-out should be saved</span>
<span class="sd">    by the respective electrode names then the following command could be used</span>

<span class="sd">    &gt;&gt;&gt; read_eeg(&#39;mytest/test.eeg&#39;,&#39;Results/test.h5&#39;,electrodelist=[&#39;RFA1&#39;,&#39;RFA3&#39;],savemat=False)</span>

<span class="sd">    In this case the `EEG` group of the resulting HDF5 file looks like this</span>

<span class="sd">    &gt;&gt;&gt; f = h5py.File(&#39;Results/test.h5&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f[&#39;EEG&#39;].keys()</span>
<span class="sd">    &gt;&gt;&gt; [&#39;RFA1&#39;, &#39;RFA3&#39;]</span>
<span class="sd">    &gt;&gt;&gt; f[&#39;EEG&#39;][&#39;RFA1&#39;].value</span>
<span class="sd">    &gt;&gt;&gt; array([32079, 32045, 32001, ..., 33607, 33556, 33530], dtype=uint16)</span>

<span class="sd">    Thus, the electrode time-courses are saved using the respective electrode names. </span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    h5py : A Pythonic interface to the HDF5 binary data format</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure `eegpath` is a string and expand &quot;~&quot; if present</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eegpath</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input has to be a string specifying the path/name of the EEG files!&#39;</span><span class="p">)</span>
    <span class="n">eegpath</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">eegpath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eegpath</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">eegpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">eegpath</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Same for `outfile`: additionally check if the path is valid</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outfile</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Output filename has to be a string!&#39;</span><span class="p">)</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outfile</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">outfile</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">slash</span> <span class="o">=</span> <span class="n">outfile</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slash</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outfile</span><span class="p">[:</span><span class="n">outfile</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid path for output file: &#39;</span><span class="o">+</span><span class="n">outfile</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">outfile</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Target HDF5 container already exists!&quot;</span><span class="p">)</span>

    <span class="c1"># Check `electrodelist`</span>
    <span class="k">if</span> <span class="n">electrodelist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">electrodelist</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input `electrodlist` must be a Python list!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">electrodelist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `electrodelist` has length 0!&#39;</span><span class="p">)</span>

    <span class="c1"># Make sure `savemat` is Boolean</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">savemat</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The optional argument `savemant` has to be Boolean!&quot;</span><span class="p">)</span>

    <span class="c1"># If file extension was provided, remove it to avoid stupid case-sensitive nonsense</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">eegpath</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eegpath</span><span class="p">[</span><span class="n">dt</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;eeg&#39;</span><span class="p">:</span>
        <span class="n">eegpath</span> <span class="o">=</span> <span class="n">eegpath</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">dt</span><span class="p">]</span>

    <span class="c1"># Extract filename from given path (if just file was provided, path is &#39;&#39;)</span>
    <span class="n">slash</span>  <span class="o">=</span> <span class="n">eegpath</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">flpath</span> <span class="o">=</span> <span class="n">eegpath</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">slash</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">flname</span> <span class="o">=</span> <span class="n">eegpath</span><span class="p">[</span><span class="n">slash</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Try to get eeg file and raise an error if it does not exist or an x.eeg and x.EEG file is found</span>
    <span class="n">eegfls</span> <span class="o">=</span> <span class="n">myglob</span><span class="p">(</span><span class="n">flpath</span><span class="p">,</span><span class="n">flname</span><span class="o">+</span><span class="s1">&#39;.[Ee][Ee][Gg]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eegfls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Filename ambiguity: found &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">eegfls</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">eegfls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flpath</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">flpath</span> <span class="o">=</span> <span class="s1">&#39;current directory&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;File &#39;</span><span class="o">+</span><span class="n">flname</span><span class="o">+</span><span class="s1">&#39;.EEG/eeg not found in &#39;</span><span class="o">+</span><span class="n">flpath</span><span class="p">)</span>

    <span class="c1"># Same for (hopefully) corresponding 21E file</span>
    <span class="n">e21fls</span> <span class="o">=</span> <span class="n">myglob</span><span class="p">(</span><span class="n">flpath</span><span class="p">,</span><span class="n">flname</span><span class="o">+</span><span class="s1">&#39;.21[Ee]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e21fls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Filename ambiguity: found &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e21fls</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">e21fls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flpath</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">flpath</span> <span class="o">=</span> <span class="s1">&#39;current directory&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;File &#39;</span><span class="o">+</span><span class="n">flname</span><span class="o">+</span><span class="s1">&#39;.21E/21e not found in &#39;</span><span class="o">+</span><span class="n">flpath</span><span class="p">)</span>

    <span class="c1"># Open file handles to *.EEG, *.21E and output files</span>
    <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">e21fls</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;rU&#39;</span><span class="p">)</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">eegfls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">f</span>   <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>

    <span class="c1"># Let the user know what&#39;s going on</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Starting reading routine...&quot;</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Successfully accessed files &quot;</span><span class="o">+</span><span class="n">eegfls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="n">e21fls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; and &quot;</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="c1"># Try to import progressbar module</span>
    <span class="k">try</span><span class="p">:</span> 
        <span class="kn">import</span> <span class="nn">progressbar</span> <span class="k">as</span> <span class="nn">pb</span>
        <span class="n">showbar</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="nb">print</span> <span class="s2">&quot;WARNING: progressbar module not found - consider installing it using pip install progressbar&quot;</span>
        <span class="n">showbar</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Skip EEG device block</span>
    <span class="n">deviceBlockLen</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">fid</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">deviceBlockLen</span><span class="p">)</span>

    <span class="c1"># Read EEG1 control Block (contains names and addresses for EEG2 blocks)</span>
    <span class="n">x</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">numberOfBlocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">blockAddress</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

    <span class="c1"># If the EEG file is a container of concatenated EEG chunks, throw an error</span>
    <span class="k">if</span> <span class="n">numberOfBlocks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;EEG file &#39;</span><span class="o">+</span><span class="n">eegfls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; seems to contain more than one recording. Exiting...&#39;</span><span class="p">)</span>

    <span class="c1"># Read EEG2m control block (contains names and addresses for waveform blocks)</span>
    <span class="n">fid</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">blockAddress</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">numberOfBlocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">blockAddress</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

    <span class="c1"># If the EEG file is a container of concatenated EEG chunks, throw an error</span>
    <span class="k">if</span> <span class="n">numberOfBlocks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;EEG file &#39;</span><span class="o">+</span><span class="n">eegfls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; seems to contain more than one recording. Exiting...&#39;</span><span class="p">)</span>

    <span class="c1"># Read waveform blockA</span>
    <span class="n">fid</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">blockAddress</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get data byte-length and mark/event flag</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get starting time </span>
    <span class="n">T_year</span>   <span class="o">=</span> <span class="n">bcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">T_month</span>  <span class="o">=</span> <span class="n">bcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">T_day</span>    <span class="o">=</span> <span class="n">bcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">T_hour</span>   <span class="o">=</span> <span class="n">bcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">T_minute</span> <span class="o">=</span> <span class="n">bcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">T_second</span> <span class="o">=</span> <span class="n">bcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

    <span class="c1"># Expand `T_year` to full format and account for millenium (i.e., 13 -&gt; 2013, 96 -&gt; 1996)</span>
    <span class="k">if</span> <span class="n">T_year</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
        <span class="n">T_year</span> <span class="o">=</span> <span class="mi">2000</span> <span class="o">+</span> <span class="n">T_year</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">T_year</span> <span class="o">=</span> <span class="mi">1900</span> <span class="o">+</span> <span class="n">T_year</span>

    <span class="c1"># Print time-stamp info</span>
    <span class="n">weeklist</span>    <span class="o">=</span> <span class="p">[</span><span class="n">day</span> <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="n">calendar</span><span class="o">.</span><span class="n">day_name</span><span class="p">]</span>
    <span class="n">monthlist</span>   <span class="o">=</span> <span class="p">[</span><span class="n">month</span> <span class="k">for</span> <span class="n">month</span> <span class="ow">in</span> <span class="n">calendar</span><span class="o">.</span><span class="n">month_name</span><span class="p">];</span> <span class="n">monthlist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">recordedstr</span> <span class="o">=</span> <span class="s2">&quot; Data was recorded on &quot;</span><span class="o">+</span><span class="n">weeklist</span><span class="p">[</span><span class="n">date</span><span class="p">(</span><span class="n">T_year</span><span class="p">,</span><span class="n">T_month</span><span class="p">,</span><span class="n">T_day</span><span class="p">)</span><span class="o">.</span><span class="n">weekday</span><span class="p">()]</span><span class="o">+</span>\
        <span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="n">monthlist</span><span class="p">[</span><span class="n">T_month</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">T_day</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">T_year</span><span class="p">)</span>
    <span class="nb">print</span> <span class="n">recordedstr</span>
    <span class="n">beginstr</span> <span class="o">=</span> <span class="s2">&quot; Begin of session: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">T_hour</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">T_minute</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">T_second</span><span class="p">)</span>
    <span class="nb">print</span> <span class="n">beginstr</span>

    <span class="c1"># Get sampling rate</span>
    <span class="n">hexopts</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;C064&#39;</span><span class="p">,</span><span class="mi">16</span><span class="p">):</span><span class="mi">100</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;C068&#39;</span><span class="p">,</span><span class="mi">16</span><span class="p">):</span><span class="mi">200</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;C1F4&#39;</span><span class="p">,</span><span class="mi">16</span><span class="p">):</span><span class="mi">500</span><span class="p">,</span>\
               <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;C3E8&#39;</span><span class="p">,</span><span class="mi">16</span><span class="p">):</span><span class="mi">1000</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;C7D0&#39;</span><span class="p">,</span><span class="mi">16</span><span class="p">):</span><span class="mi">2000</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;D388&#39;</span><span class="p">,</span><span class="mi">16</span><span class="p">):</span><span class="mi">5000</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;E710&#39;</span><span class="p">,</span><span class="mi">16</span><span class="p">):</span><span class="mi">10000</span><span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">actSamplerate</span> <span class="o">=</span> <span class="n">hexopts</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">))]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;ERROR: Unknown Sampling Rate&quot;</span><span class="p">;</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
    <span class="n">sratestr</span> <span class="o">=</span> <span class="s2">&quot; Sampling rate: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">actSamplerate</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; Hz&quot;</span>
    <span class="nb">print</span> <span class="n">sratestr</span>

    <span class="c1"># Get length of scan</span>
    <span class="n">num100msBlocks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">lengthstr</span>      <span class="o">=</span>  <span class="s2">&quot; Length of session: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">num100msBlocks</span><span class="o">/</span><span class="mi">10</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; hours&quot;</span>
    <span class="nb">print</span> <span class="n">lengthstr</span>

    <span class="c1"># More scanning parameters</span>
    <span class="n">numSamples</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">actSamplerate</span><span class="o">*</span><span class="n">num100msBlocks</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">AD_off</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">AD_val</span>      <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">bitLen</span>      <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">comFlag</span>     <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">numChannels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Read electrode codes and names using csv module</span>
    <span class="n">reader</span>       <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
    <span class="n">allCodeNames</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">allCodeNames</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;[SD_DEF]&#39;</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="c1"># Define good electrode codes and bad electrode names</span>
    <span class="n">goodCodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">37</span><span class="p">),</span><span class="mi">74</span><span class="p">,</span><span class="mi">75</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">254</span><span class="p">))))</span>
    <span class="n">badNames</span>  <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>

    <span class="c1"># Build list of actually used electrodes in this file and their corresponding indices</span>
    <span class="n">actualNames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">CALopts</span>     <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span><span class="mi">5</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span><span class="mi">6</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span><span class="mi">8</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">1000</span><span class="p">}</span>
    <span class="n">GAIN</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numChannels</span><span class="p">,))</span>
    <span class="n">goodElec</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numChannels</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numChannels</span><span class="p">):</span>
        <span class="n">x</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ActualName</span> <span class="o">=</span> <span class="n">allCodeNames</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">goodCodes</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">badNames</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ActualName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">goodElec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">actualNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;###&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">goodElec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 
            <span class="n">actualNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ActualName</span><span class="p">)</span>

        <span class="c1"># Skip 6 bits starting at current position</span>
        <span class="n">fid</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Read channel sensitivity and determine `CAL` in microvolts</span>
        <span class="n">chan_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">CAL</span>       <span class="o">=</span> <span class="n">CALopts</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">))]</span>
        <span class="n">GAIN</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="n">CAL</span><span class="o">/</span><span class="n">AD_val</span>

    <span class="c1"># Abort if channels show difference in gain</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">GAIN</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Channels do not have the same gain!&quot;</span><span class="p">)</span>

    <span class="c1"># If user provided list of electrodes to read check it now</span>
    <span class="k">if</span> <span class="n">electrodelist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idxlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">electrodelist</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">actualNames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Electrode &#39;</span><span class="o">+</span><span class="n">el</span><span class="o">+</span><span class="s1">&#39; not found in file!&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">goodElec</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="n">idxlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;WARNING: Electrode &quot;</span><span class="o">+</span><span class="n">el</span><span class="o">+</span><span class="s2">&quot; not in trusted electrode list! Skipping it...&quot;</span>

        <span class="c1"># In case the electrodlist was not ordered as the binary file, fix this </span>
        <span class="n">idxlist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Synchronize `goodElec` and `electrodelist`</span>
        <span class="n">goodElec</span><span class="p">[:]</span>       <span class="o">=</span> <span class="kc">False</span> 
        <span class="n">goodElec</span><span class="p">[</span><span class="n">idxlist</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># The indexlist is the whole &quot;good&quot; `goodElec` array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idxlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">goodElec</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># The data type of the raw data is unsigned integer. Define that and the bytesize of uint16 here</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="c1"># Create a group holding the raw data</span>
    <span class="n">eeg</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;EEG&#39;</span><span class="p">)</span>

    <span class="c1"># Depending on available memory, allocate temporary matrix</span>
    <span class="n">meminfo</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()</span>
    <span class="n">maxmem</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">meminfo</span><span class="o">.</span><span class="n">available</span><span class="o">*</span><span class="mf">0.25</span><span class="o">/</span><span class="p">(</span><span class="n">numChannels</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">ds</span><span class="p">))</span>

    <span class="c1"># If the whole array fits into memory load it once, otherwise chunk it up</span>
    <span class="k">if</span> <span class="n">numSamples</span> <span class="o">&lt;=</span> <span class="n">maxmem</span><span class="p">:</span>
        <span class="n">blocksize</span> <span class="o">=</span> <span class="p">[</span><span class="n">numSamples</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">blocksize</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxmem</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">numSamples</span><span class="o">//</span><span class="n">maxmem</span><span class="p">)</span>
        <span class="n">rest</span>      <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">numSamples</span><span class="p">,</span><span class="n">maxmem</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rest</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">+</span> <span class="p">[</span><span class="n">rest</span><span class="p">]</span>

    <span class="c1"># Count the number of blocks we split up data into</span>
    <span class="n">numblocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocksize</span><span class="p">)</span>

    <span class="c1"># Allocate matrix to temporarily hold data</span>
    <span class="n">datamat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numChannels</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">blocksize</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>

    <span class="c1"># Depending on the user wanting to save stuff as matrix, prepare dataset </span>
    <span class="n">numnodes</span> <span class="o">=</span> <span class="n">goodElec</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">savemat</span><span class="p">):</span> 
        <span class="n">nodelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">goodElec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span> 
            <span class="k">if</span> <span class="n">goodElec</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> 
                <span class="n">nodelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">actualNames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;electrode_list&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">nodelist</span><span class="p">)</span>
        <span class="n">eeg_mat</span> <span class="o">=</span> <span class="n">eeg</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;eeg_mat&#39;</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">numnodes</span><span class="p">,</span><span class="n">numSamples</span><span class="p">),</span><span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">numSamples</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxlist</span><span class="p">:</span>
            <span class="n">eeg</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">actualNames</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">numSamples</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>

    <span class="c1"># If available, initialize progressbar</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span> 
        <span class="n">widgets</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Processing data block-wise... &#39;</span><span class="p">,</span><span class="n">pb</span><span class="o">.</span><span class="n">Percentage</span><span class="p">(),</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">pb</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">),</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">pb</span><span class="o">.</span><span class="n">ETA</span><span class="p">()]</span>
        <span class="n">pbar</span>    <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">ProgressBar</span><span class="p">(</span><span class="n">widgets</span><span class="o">=</span><span class="n">widgets</span><span class="p">,</span><span class="n">maxval</span><span class="o">=</span><span class="n">numblocks</span><span class="p">)</span>

    <span class="c1"># Here we go...</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Reading data in &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">numblocks</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; block(s)...</span><span class="se">\n</span><span class="s2"> &quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># Read/write data block by block</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numblocks</span><span class="p">):</span>

        <span class="c1"># Read data block-wise and save to matrix or row (depending on user choice, add offset to get int16)</span>
        <span class="n">bsize</span>   <span class="o">=</span> <span class="n">blocksize</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">datamat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="n">bsize</span><span class="o">*</span><span class="p">(</span><span class="n">numChannels</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">numChannels</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">bsize</span><span class="p">),</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">AD_off</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">savemat</span><span class="p">):</span>
            <span class="n">eeg_mat</span><span class="p">[:,</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">bsize</span><span class="p">]</span> <span class="o">=</span> <span class="n">datamat</span><span class="p">[</span><span class="n">idxlist</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">bsize</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxlist</span><span class="p">:</span>
                <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="n">actualNames</span><span class="p">[</span><span class="n">idx</span><span class="p">]][</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">bsize</span><span class="p">]</span> <span class="o">=</span> <span class="n">datamat</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">bsize</span><span class="p">]</span>

        <span class="c1"># Update index counter </span>
        <span class="n">j</span> <span class="o">+=</span> <span class="n">bsize</span>

        <span class="c1"># Update progressbar</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span> 
            <span class="n">widgets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; Processing block &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">numblocks</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; &#39;</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># If progressbar is available, end it now</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

    <span class="c1"># Write meta-data</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;summary&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">recordedstr</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">beginstr</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">sratestr</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">lengthstr</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;record_date&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">T_year</span><span class="p">,</span><span class="n">T_month</span><span class="p">,</span><span class="n">T_day</span><span class="p">,</span><span class="n">T_hour</span><span class="p">,</span><span class="n">T_minute</span><span class="p">,</span><span class="n">T_second</span><span class="p">])</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">actSamplerate</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;session_length&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">num100msBlocks</span><span class="o">/</span><span class="mi">10</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;AD_off&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">AD_off</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;AD_val&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">AD_val</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;CAL&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">CAL</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;comFlag&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">comFlag</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;bitLen&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">bitLen</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;numSamples&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">numSamples</span><span class="p">)</span>
    <span class="n">eeg</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s1">&#39;sourcefile&#39;</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">eegfls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Close and finalize HDF write process</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="nb">print</span> <span class="s2">&quot; Done. &quot;</span>

    <span class="k">return</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="load_data"><a class="viewcode-back" href="../_stubs/eeg_tools.load_data.html#eeg_tools.load_data">[docs]</a><span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="n">h5file</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load data from HDF5 container generated with `read_eeg`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5file : str or h5py.File instance</span>
<span class="sd">        String specifying file name (or path + filename) or `h5py.File` instance of</span>
<span class="sd">        HDF5 container to be accessed</span>
<span class="sd">    nodes : list or NumPy 1darray</span>
<span class="sd">        Python list or NumPy array of electrodes to be read. Can be either an array/list</span>
<span class="sd">        of strings or indices. By default `nodes=None` and all electrodes are read </span>
<span class="sd">        from file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : NumPy 2darray</span>
<span class="sd">        A `#nodes`-by-`#samples` array holding the data in float64 format</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The raw iEEG data are stored as int16. This routine normalizes (divides by max(int16))</span>
<span class="sd">    and rescales the data based on the original channel sensitivity (read from the HDF5</span>
<span class="sd">    container). </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose we want to read data stored in the file `iEEG.h5`. To access all of its contents</span>
<span class="sd">    use</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; data = load_data(&#39;iEEG.h5&#39;)</span>
<span class="sd">    &gt;&gt;&gt; data.shape</span>
<span class="sd">    &gt;&gt;&gt; (84, 9000000)</span>

<span class="sd">    If the HDF5 container is already open and only electrodes `RFA1` and `RFB1` should be read</span>
<span class="sd">    use</span>

<span class="sd">    &gt;&gt;&gt; import h5py</span>
<span class="sd">    &gt;&gt;&gt; f = h5py.File(&#39;iEEG.h5&#39;)</span>
<span class="sd">    &gt;&gt;&gt; data = load_data(f,nodes=[&#39;RFA1&#39;,&#39;RFB1&#39;])</span>
<span class="sd">    &gt;&gt;&gt; data.shape</span>
<span class="sd">    &gt;&gt;&gt; (2, 9000000)</span>

<span class="sd">    Alternatively, nodes can be specified using their indices in the file </span>

<span class="sd">    &gt;&gt;&gt; data = load_data(f,nodes=np.array([12,33]))</span>
<span class="sd">    &gt;&gt;&gt; data.shape</span>
<span class="sd">    &gt;&gt;&gt; (2, 9000000)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    read_eeg : Read raw EEG data from binary *.EEG/*.eeg and *.21E files</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if input HDF5 container makes sense</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">closefile</span><span class="p">,</span> <span class="n">ismat</span><span class="p">,</span> <span class="n">ec_list</span> <span class="o">=</span> <span class="n">check_hdf</span><span class="p">(</span><span class="n">h5file</span><span class="p">)</span>

    <span class="c1"># Get indices of nodes to be read</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ec_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node &quot;</span><span class="o">+</span><span class="n">node</span><span class="o">+</span><span class="s2">&quot; not found in file &quot;</span><span class="o">+</span><span class="n">h5file</span><span class="o">+</span><span class="s2">&quot;!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ec_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Indices not found in file &quot;</span><span class="o">+</span><span class="n">h5file</span><span class="o">+</span><span class="s2">&quot;!&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span> 
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Nodes have to be provided as Python list/NumPy 1darray of indices or strings!&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found float &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, integer required!&quot;</span><span class="p">)</span>
                <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ec_list</span><span class="p">))</span>

    <span class="c1"># Get channel units and number of samples in file</span>
    <span class="n">CAL</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;CAL&#39;</span><span class="p">]</span>
    <span class="n">N</span>   <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;numSamples&#39;</span><span class="p">]</span>

    <span class="c1"># Extract data from HDF5 file and divide by upper bound of dtype (-&gt; values b/w -1/+1), multiply by `CAL`</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span><span class="n">N</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ismat</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="s1">&#39;eeg_mat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">k</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="s1">&#39;eeg_mat&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:]</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="o">*</span><span class="n">CAL</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="o">*</span><span class="n">CAL</span>

    <span class="c1"># Close file if user provided just string</span>
    <span class="k">if</span> <span class="n">closefile</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
    <span class="k">return</span> <span class="n">data</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="MA"><a class="viewcode-back" href="../_stubs/eeg_tools.MA.html#eeg_tools.MA">[docs]</a><span class="k">def</span> <span class="nf">MA</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">past</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth 1d/2darray using a moving average filter along one axis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : NumPy 1d/2darray</span>
<span class="sd">        Input signal of shape `M`-by-`N`, where `M` is the number of signal sources (regions, measuring</span>
<span class="sd">        devices, etc.) and `N` is the number of observations/measurements. Smoothing is performed along the </span>
<span class="sd">        second axis, i.e., for each source all `N` observations are smoothed independently of each other</span>
<span class="sd">        using the same moving average window. </span>
<span class="sd">    window_size : int</span>
<span class="sd">        Positive scalar defining the size of the window to average over</span>
<span class="sd">    past : bool</span>
<span class="sd">        If `past = True` then only preceding data is used to calculate the moving average. In addition, </span>
<span class="sd">        the rolling standard deviation is also computed. For `past = False` the input signal is </span>
<span class="sd">        filtered using an MA sliding window that averages across data points between </span>
<span class="sd">        `- window_size/2` and `window_size/2`. If `past = False` no rolling standard deviation is </span>
<span class="sd">        calculated. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    If `past == True`</span>
<span class="sd">    ma_signal : NumPy 1d/2darray</span>
<span class="sd">        Moving average of signal (same shape as input)</span>
<span class="sd">    sd_signal : NumPy 1d/2darray</span>
<span class="sd">        Rolling Standard deviation of signal (same shape as input)</span>

<span class="sd">    If `past == False`</span>
<span class="sd">    ma_signal : NumPy 1d/2darray</span>
<span class="sd">        Smoothed signal (same shape as input)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">shs</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Signal must be a 1d/2d NumPy array, not &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Signal must be a 1d/2d NumPy array&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">shs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Signal only consists of one datapoint!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Signal must be a real-valued &#39;</span><span class="o">+</span><span class="n">dim_msg</span><span class="o">+</span><span class="s1">&#39; NumPy array!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Signal must be a real valued NumPy array without Infs or NaNs!&#39;</span><span class="p">)</span>

    <span class="c1"># Check `window_size`</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span><span class="s1">&#39;window_size&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input `window-size` must be a positive integer!&quot;</span><span class="p">)</span>

    <span class="c1"># Check if `past` is Boolean</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">past</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The optional argument `past` has to be Boolean!&quot;</span><span class="p">)</span>

    <span class="c1"># Use only preceding data points to calculate MA</span>
    <span class="k">if</span> <span class="n">past</span><span class="p">:</span>

        <span class="c1"># If the signal is 1D, reshape it so that the for loops work</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">signal</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

        <span class="c1"># Allocate space for output</span>
        <span class="n">ma_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">sd_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># The first `window_size` entries are computed using an incremental average/variation computation</span>
        <span class="c1"># (update mean/variance by each new element that is added)</span>
        <span class="n">ma_signal</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">window_size</span><span class="p">):</span>
            <span class="n">ma_signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ma_signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sd_signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">sd_signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">ma_signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">ma_signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
     
        <span class="c1"># The remaining entries are the actual moving average/rolling variation</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">ma_signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ma_signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="n">window_size</span><span class="p">])</span><span class="o">/</span><span class="n">window_size</span>
            <span class="n">sd_signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">ma_signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="n">window_size</span><span class="p">]</span> <span class="o">-</span> <span class="n">ma_signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span>\
                           <span class="p">(</span><span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">signal</span><span class="p">[:,</span><span class="n">k</span><span class="o">-</span><span class="n">window_size</span><span class="p">])</span><span class="o">/</span><span class="n">window_size</span>
     
        <span class="c1"># To get the standard deviation, compute the sqrt of the rolling variation</span>
        <span class="n">sd_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sd_signal</span><span class="o">*</span><span class="p">(</span><span class="n">sd_signal</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># In case we had a 1D signal, remove the unnecessary dimension</span>
        <span class="n">ma_signal</span> <span class="o">=</span> <span class="n">ma_signal</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">sd_signal</span> <span class="o">=</span> <span class="n">sd_signal</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ma_signal</span><span class="p">,</span> <span class="n">sd_signal</span>

    <span class="c1"># Much faster: use a convolution to compute the mean over `[-window_size/2,0,window_size/2]`</span>
    <span class="k">else</span><span class="p">:</span>
        
        <span class="c1"># Assemble window and compute moving average of signal</span>
        <span class="n">window</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">window_size</span><span class="p">))</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
        <span class="n">ma_signal</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">convolve1d</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span><span class="n">window</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ma_signal</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="time2ind"><a class="viewcode-back" href="../_stubs/eeg_tools.time2ind.html#eeg_tools.time2ind">[docs]</a><span class="k">def</span> <span class="nf">time2ind</span><span class="p">(</span><span class="n">h5file</span><span class="p">,</span><span class="n">t_start</span><span class="p">,</span><span class="n">t_end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert human readable 24hr times to indices used in given iEEG file container</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5file : str or h5py.File instance</span>
<span class="sd">        String specifying file name (or path + filename) or `h5py.File` instance of</span>
<span class="sd">        HDF5 container to be accessed</span>
<span class="sd">    t_start : list/NumPy 1darray</span>
<span class="sd">        Start time in 24hr format. Syntax is [hh,mm,ss]</span>
<span class="sd">    t_end : list/NumPy 1darray</span>
<span class="sd">        End time in 24hr format. Syntax is [hh,mm,ss]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ind_start : int</span>
<span class="sd">        Index of iEEG array corresponding to provided start time `t_start`</span>
<span class="sd">    ind_stop : int</span>
<span class="sd">        Index of iEEG array corresponding to provided end time `t_stop`</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    load_data : Load data from HDF5 container generated with read_eeg</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if input HDF5 container makes sense</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">closefile</span><span class="p">,</span> <span class="n">ismat</span><span class="p">,</span> <span class="n">ec_list</span> <span class="o">=</span> <span class="n">check_hdf</span><span class="p">(</span><span class="n">h5file</span><span class="p">)</span>

    <span class="c1"># Check start/end times</span>
    <span class="k">for</span> <span class="n">t_lst</span> <span class="ow">in</span> <span class="p">[</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_lst</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Start and end times must be Python lists!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_lst</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Start and end times must be 3-element lists&quot;</span><span class="p">)</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">t_lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;Start/end hour&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">23</span><span class="p">])</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">t_lst</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;Start/end minute&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">59</span><span class="p">])</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">t_lst</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="s1">&#39;Start/end second&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">59</span><span class="p">])</span>

    <span class="c1"># Read session date and sampling rate from file</span>
    <span class="n">sess_start</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;record_date&#39;</span><span class="p">]</span>
    <span class="n">s_rate</span>     <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]</span>

    <span class="c1"># Extract hours of session start, on- and offsets</span>
    <span class="n">sess_hour</span> <span class="o">=</span> <span class="n">sess_start</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">ts_hour</span>   <span class="o">=</span> <span class="n">t_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">te_hour</span>   <span class="o">=</span> <span class="n">t_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Convert session date to datetime object</span>
    <span class="n">sess_begin</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">sess_start</span><span class="p">)</span>

    <span class="c1"># Compute session end</span>
    <span class="n">sess_stop</span> <span class="o">=</span> <span class="n">sess_begin</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;session_length&#39;</span><span class="p">])</span>

    <span class="c1"># Combine session date (sess_start[0:3] gives [yr,mnth,day]) with onset time ([hr,min,sec]) </span>
    <span class="n">ts_date</span> <span class="o">=</span> <span class="n">sess_start</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">t_begin</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ts_date</span><span class="p">,</span><span class="n">t_start</span><span class="p">]))</span>

    <span class="c1"># If onset hour is less than session hour (01 vs 23), we crossed the 12AM mark, correct t_begin</span>
    <span class="k">if</span> <span class="n">sess_hour</span> <span class="o">&gt;</span> <span class="n">ts_hour</span><span class="p">:</span>
        <span class="n">t_begin</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Same for offset time</span>
    <span class="n">te_date</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_begin</span><span class="o">.</span><span class="n">year</span><span class="p">,</span><span class="n">t_begin</span><span class="o">.</span><span class="n">month</span><span class="p">,</span><span class="n">t_begin</span><span class="o">.</span><span class="n">day</span><span class="p">]</span>
    <span class="n">t_stop</span>  <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">te_date</span><span class="p">,</span><span class="n">t_end</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">ts_hour</span> <span class="o">&gt;</span> <span class="n">te_hour</span><span class="p">:</span>
        <span class="n">t_stop</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># If session begin is later than onset time, raise an error</span>
    <span class="k">if</span> <span class="n">sess_begin</span> <span class="o">&gt;</span> <span class="n">t_begin</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Recording starts at &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">sess_begin</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; which is after provided start time at &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t_begin</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Analogously for offset time</span>
    <span class="k">if</span> <span class="n">sess_stop</span> <span class="o">&lt;</span> <span class="n">t_stop</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Recording stops at &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">sess_stop</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; which is before provided stop time at &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t_stop</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># That&#39;s why we use datetime: subtract objects to get time differences</span>
    <span class="n">ts_offset</span> <span class="o">=</span> <span class="n">t_begin</span> <span class="o">-</span> <span class="n">sess_begin</span> 
    <span class="n">te_offset</span> <span class="o">=</span> <span class="n">t_stop</span> <span class="o">-</span> <span class="n">sess_begin</span>

    <span class="c1"># Indices are computed as offset seconds * sampling rate</span>
    <span class="n">ind_start</span> <span class="o">=</span> <span class="n">ts_offset</span><span class="o">.</span><span class="n">seconds</span><span class="o">*</span><span class="n">s_rate</span>
    <span class="n">ind_stop</span>  <span class="o">=</span> <span class="n">te_offset</span><span class="o">.</span><span class="n">seconds</span><span class="o">*</span><span class="n">s_rate</span>

    <span class="c1"># Close file if user provided just string</span>
    <span class="k">if</span> <span class="n">closefile</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Return converted start/stop indices</span>
    <span class="k">return</span> <span class="n">ind_start</span><span class="p">,</span> <span class="n">ind_stop</span></div>

<span class="c1">##########################################################################################</span>
<span class="k">def</span> <span class="nf">check_hdf</span><span class="p">(</span><span class="n">h5file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Local helper function performing sanity checks on HDF5 containers</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># See if we can open provided HDF5 container</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">h5file</span><span class="p">)</span> <span class="o">==</span> <span class="n">h5file</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5file</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error opening file &quot;</span><span class="o">+</span><span class="n">h5file</span><span class="p">)</span>
        <span class="n">closefile</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">h5file</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;File&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">h5file</span><span class="o">.</span><span class="n">filename</span> 
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input is not a valid HDF5 file!&#39;</span><span class="p">)</span>
        <span class="n">f</span>         <span class="o">=</span> <span class="n">h5file</span>
        <span class="n">closefile</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input has to be a string specifying an HDF5 file or h5py.File instance!&#39;</span><span class="p">)</span>

    <span class="c1"># Check if data is stored as matrix or &quot;tagged list&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ismat</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;eeg_mat&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input file &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">h5file</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; does not seem to be an EEG data file...&quot;</span><span class="p">)</span>

    <span class="c1"># Get list of electrodes actually present in file</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ismat</span><span class="p">):</span>
        <span class="n">ec_list</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;electrode_list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ec_list</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="c1"># Return HDF5 file object and tell caller if </span>
    <span class="c1"># container uses an array (`ismat = True`) or named list storage format and</span>
    <span class="c1"># if the file needs to be closed at the end (`closefile = True`)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">closefile</span><span class="p">,</span> <span class="n">ismat</span><span class="p">,</span> <span class="n">ec_list</span>

<span class="c1">##########################################################################################</span>
<span class="k">def</span> <span class="nf">scalarcheck</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">varname</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Local helper function performing sanity checks on scalars</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be a real scalar!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be finite!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be an integer!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input scalar `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be between &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; and &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;!&quot;</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>