<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nws_tools</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/myaddon.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          Analytic Tools Documentation</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://www.masseyeandear.org/research/otolaryngology/investigators/laboratories/simonyanlab">Dystonia and Motor Control Laboratory</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Browse <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Welcome to the Analytic Tools Documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#getting-started">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#network-science">Network Science</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#interactive-brain-network-visualization">Interactive Brain Network Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#intracranial-eeg-data-processing">Intracranial EEG Data Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#comparative-statistics">Comparative Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#general-purpose-convenience-functions">General-Purpose Convenience Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#neural-population-modeling">Neural Population Modeling</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Navigate <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for nws_tools</h1><div class="highlight"><pre>
<span></span><span class="c1"># nws_tools.py - Collection of network creation/processing/analysis/plotting routines</span>
<span class="c1"># </span>
<span class="c1"># Author: Stefan Fuertinger [stefan.fuertinger@esi-frankfurt.de]</span>
<span class="c1"># Created: December 22 2014</span>
<span class="c1"># Last modified: &lt;2017-09-15 16:05:40&gt;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">natsort</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">weave</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">weave</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">Axes3D</span><span class="p">,</span> <span class="n">proj3d</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="k">import</span> <span class="n">FancyArrowPatch</span><span class="p">,</span> <span class="n">Circle</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="k">import</span> <span class="n">Normalize</span><span class="p">,</span> <span class="n">colorConverter</span><span class="p">,</span> <span class="n">LightSource</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">recipes</span> <span class="k">import</span> <span class="n">myglob</span>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="strengths_und"><a class="viewcode-back" href="../_stubs/nws_tools.strengths_und.html#nws_tools.strengths_und">[docs]</a><span class="k">def</span> <span class="nf">strengths_und</span><span class="p">(</span><span class="n">CIJ</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute nodal strengths in an undirected graph</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    CIJ : NumPy 2darray</span>
<span class="sd">        Undirected binary/weighted connection matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    st : NumPy 1darray</span>
<span class="sd">        Nodal strength vector</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function does *not* do any error checking and assumes you know what you are doing</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    strengths_und.m : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                      `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    bctpy : An unofficial Python port of the BCT is currently available at the </span>
<span class="sd">            `Python Package Index &lt;https://pypi.python.org/pypi/bctpy&gt;`_</span>
<span class="sd">            and can be installed using `pip`. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">CIJ</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="degrees_und"><a class="viewcode-back" href="../_stubs/nws_tools.degrees_und.html#nws_tools.degrees_und">[docs]</a><span class="k">def</span> <span class="nf">degrees_und</span><span class="p">(</span><span class="n">CIJ</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute nodal degrees in an undirected graph</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    CIJ : NumPy 2darray</span>
<span class="sd">        Undirected binary/weighted connection matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    deg : NumPy 1darray</span>
<span class="sd">        Nodal degree vector</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function does *not* do any error checking and assumes you know what you are doing</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    degrees_und.m : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                    `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    bctpy : An unofficial Python port of the BCT is currently available at the </span>
<span class="sd">            `Python Package Index &lt;https://pypi.python.org/pypi/bctpy&gt;`_</span>
<span class="sd">            and can be installed using `pip`. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">CIJ</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="density_und"><a class="viewcode-back" href="../_stubs/nws_tools.density_und.html#nws_tools.density_und">[docs]</a><span class="k">def</span> <span class="nf">density_und</span><span class="p">(</span><span class="n">CIJ</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the connection density of an undirected graph</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    CIJ : NumPy 2darray</span>
<span class="sd">        Undirected binary/weighted connection matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    den : float</span>
<span class="sd">        density (fraction of present connections to possible connections)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function does *not* do any error checking and assumes you know what you are doing</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    density_und.m : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                    `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    bctpy : An unofficial Python port of the BCT is currently available at the </span>
<span class="sd">            `Python Package Index &lt;https://pypi.python.org/pypi/bctpy&gt;`_</span>
<span class="sd">            and can be installed using `pip`. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">CIJ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                    <span class="c1"># no. of nodes</span>
    <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">CIJ</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>       <span class="c1"># no. of edges</span>
    <span class="k">return</span> <span class="n">K</span><span class="o">/</span><span class="p">((</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="get_corr"><a class="viewcode-back" href="../_stubs/nws_tools.get_corr.html#nws_tools.get_corr">[docs]</a><span class="k">def</span> <span class="nf">get_corr</span><span class="p">(</span><span class="n">txtpath</span><span class="p">,</span><span class="n">corrtype</span><span class="o">=</span><span class="s1">&#39;pearson&#39;</span><span class="p">,</span><span class="n">sublist</span><span class="o">=</span><span class="p">[],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute pair-wise statistical dependence of time-series</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    txtpath : str</span>
<span class="sd">        Path to directory holding ROI-averaged time-series dumped in `txt` files.</span>
<span class="sd">        The following file-naming convention is required `sNxy_bla_bla.txt`, </span>
<span class="sd">        where `N` is the group id (1,2,3,...), `xy` denotes the subject number </span>
<span class="sd">        (01,02,...,99 or 001,002,...,999) and anything else is separated </span>
<span class="sd">        by underscores. The files will be read in lexicographic order,</span>
<span class="sd">        i.e., `s101_1.txt`, `s101_2.txt`,... or `s101_Amygdala.txt`, `s101_Beemygdala`,...</span>
<span class="sd">        See Notes for more details. </span>
<span class="sd">    corrtype : str</span>
<span class="sd">        Specifier indicating which type of statistical dependence to use to compute </span>
<span class="sd">        pairwise dependence. Currently supported options are </span>

<span class="sd">                `pearson`: the classical zero-lag Pearson correlation coefficient </span>
<span class="sd">                (see NumPy&#39;s `corrcoef` for details)</span>

<span class="sd">                `mi`: (normalized) mutual information </span>
<span class="sd">                (see the docstring of `mutual_info` in this module for details)</span>
<span class="sd">    sublist : list or NumPy 1darray</span>
<span class="sd">        List of subject codes to process, e.g., `sublist = [&#39;s101&#39;,&#39;s102&#39;]`. </span>
<span class="sd">        By default all subjects found in `txtpath` will be processed.</span>
<span class="sd">    **kwargs : keyword arguments</span>
<span class="sd">        Additional keyword arguments to be passed on to the function computing </span>
<span class="sd">        the pairwise dependence (currently either NumPy&#39;s `corrcoef` or `mutual_info`</span>
<span class="sd">        in this module). </span>
<span class="sd">       </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : dict</span>
<span class="sd">        Dictionary with fields:</span>

<span class="sd">        corrs : NumPy 3darray</span>
<span class="sd">            `N`-by-`N` matrices of pair-wise regional statistical dependencies </span>
<span class="sd">	    of `numsubs` subjects. Format is `corrs.shape = (N,N,numsubs)` such that</span>
<span class="sd">            `corrs[:,:,i]` = `N x N` statistical dependence matrix of `i`-th subject </span>
<span class="sd">        bigmat : NumPy 3darray</span>
<span class="sd">            Tensor holding unprocessed time series of all subjects. Format is </span>
<span class="sd">            `bigmat.shape = (tlen,N,numsubs)` where `tlen` is the maximum </span>
<span class="sd">            time-series-length across all subjects (if time-series of different </span>
<span class="sd">            lengths were used in the computation, any unfilled entries in `bigmat` </span>
<span class="sd">            will be NumPy `nan`&#39;s, see Notes for details) and `N` is the number of </span>
<span class="sd">            regions (=nodes in the networks). </span>
<span class="sd">        sublist : list of strings</span>
<span class="sd">            List of processed subjects specified by `txtpath`, e.g.,</span>
<span class="sd">            `sublist = [&#39;s101&#39;,&#39;s103&#39;,&#39;s110&#39;,&#39;s111&#39;,&#39;s112&#39;,...]`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Per-subject time-series do not necessarily have to be of the same length across </span>
<span class="sd">    a subject cohort. However, all ROI-time-courses *within* the same subject must have </span>
<span class="sd">    the same number of entries. </span>
<span class="sd">    For instance, all ROI-time-courses in `s101` can have 140 entries, and time-series </span>
<span class="sd">    of `s102` might have 130 entries. The remaining 10 values &quot;missing&quot; for `s102` are </span>
<span class="sd">    filled with `NaN`&#39;s in `bigmat`. However, if `s101_2.txt` contains 140 data-points while only </span>
<span class="sd">    130 entries are found in `s101_3.txt`, the code will raise a `ValueError`. </span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    corrcoef : Pearson product-moment correlation coefficents computed in NumPy</span>
<span class="sd">    mutual_info : Compute (normalized) mutual information coefficients</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure `txtpath` doesn&#39;t contain nonsense and points to an existing location</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">txtpath</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input has to be a string specifying the path to the txt-file directory!&#39;</span><span class="p">)</span>
    <span class="n">txtpath</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">txtpath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">txtpath</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">txtpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">txtpath</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">txtpath</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid directory: &#39;</span><span class="o">+</span><span class="n">txtpath</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>

    <span class="c1"># Check `corrtype`</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corrtype</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Statistical dependence type input must be a string, not &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">corrtype</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">corrtype</span> <span class="o">!=</span> <span class="s1">&#39;mi&#39;</span> <span class="ow">and</span> <span class="n">corrtype</span> <span class="o">!=</span> <span class="s1">&#39;pearson&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Currently, only Pearson and (N)MI supported!&quot;</span><span class="p">)</span>

    <span class="c1"># Check `sublist`</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sublist</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Subject codes have to be provided as Python list/NumPy 1darray, not &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Subject codes have to be provided as 1-d list/array!&quot;</span><span class="p">)</span>

    <span class="c1"># Get length of `sublist` (to see if a subject list was provided)</span>
    <span class="n">numsubs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span>

    <span class="c1"># Get list of all txt-files in `txtpath` and order them lexicographically</span>
    <span class="k">if</span> <span class="n">txtpath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span>  <span class="ow">or</span> <span class="n">txtpath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">:</span> <span class="n">txtpath</span> <span class="o">=</span> <span class="n">txtpath</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">txtfiles</span> <span class="o">=</span> <span class="n">natsort</span><span class="o">.</span><span class="n">natsorted</span><span class="p">(</span><span class="n">myglob</span><span class="p">(</span><span class="n">txtpath</span><span class="p">,</span><span class="s2">&quot;s*.[Tt][Xx][Tt]&quot;</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">txtfiles</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found fewer than 2 text files in &#39;</span><span class="o">+</span><span class="n">txtpath</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>

    <span class="c1"># If no subject-list was provided, take first subject to get the number of ROIs to be processed</span>
    <span class="k">if</span> <span class="n">numsubs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Search from left in file-name for first &quot;s&quot; (naming scheme: sNxy_bla_bla_.txt)</span>
        <span class="n">firstsub</span>  <span class="o">=</span> <span class="n">txtfiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">firstsub</span>  <span class="o">=</span> <span class="n">firstsub</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">txtpath</span><span class="o">+</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">s_in_name</span> <span class="o">=</span> <span class="n">firstsub</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
    
        <span class="c1"># The characters right of &quot;s&quot; until the first &quot;_&quot; are the subject identifier</span>
        <span class="n">udrline</span> <span class="o">=</span> <span class="n">firstsub</span><span class="p">[</span><span class="n">s_in_name</span><span class="p">::]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">subject</span> <span class="o">=</span> <span class="n">firstsub</span><span class="p">[</span><span class="n">s_in_name</span><span class="p">:</span><span class="n">s_in_name</span><span class="o">+</span><span class="n">udrline</span><span class="p">]</span>

        <span class="c1"># Generate list of subjects</span>
        <span class="n">sublist</span> <span class="o">=</span> <span class="p">[</span><span class="n">subject</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">txtfiles</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fl</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">subject</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s_in_name</span> <span class="o">=</span> <span class="n">fl</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                <span class="n">udrline</span>   <span class="o">=</span> <span class="n">fl</span><span class="p">[</span><span class="n">s_in_name</span><span class="p">::]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                <span class="n">subject</span>   <span class="o">=</span> <span class="n">fl</span><span class="p">[</span><span class="n">s_in_name</span><span class="p">:</span><span class="n">s_in_name</span><span class="o">+</span><span class="n">udrline</span><span class="p">]</span>
                <span class="n">sublist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subject</span><span class="p">)</span>

        <span class="c1"># Update `numsubs`</span>
        <span class="n">numsubs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span>

        <span class="c1"># Prepare output message</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Found &quot;</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Just take the first entry of user-provided subject list</span>
        <span class="n">subject</span> <span class="o">=</span> <span class="n">sublist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Prepare output message</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Processing &quot;</span>

    <span class="c1"># Talk to the user</span>
    <span class="n">substr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span>
    <span class="n">substr</span> <span class="o">=</span> <span class="n">substr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">substr</span> <span class="o">=</span> <span class="n">substr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span> <span class="n">msg</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">numsubs</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; subjects: &quot;</span><span class="o">+</span><span class="n">substr</span>

    <span class="c1"># Get number of regions</span>
    <span class="n">numregs</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">txtfiles</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">subject</span><span class="p">)</span>
    
    <span class="c1"># Get (actual) number of subjects</span>
    <span class="n">numsubs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span>

    <span class="c1"># Scan files to find time-series length</span>
    <span class="n">tlens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numsubs</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
        <span class="n">roi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">txtfiles</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fl</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ts_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot read file &quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">roi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tlens</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts_vec</span><span class="o">.</span><span class="n">size</span>     <span class="c1"># Subject&#39;s first TS sets our reference length</span>
                <span class="k">if</span> <span class="n">ts_vec</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">tlens</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error reading file: &quot;</span><span class="o">+</span><span class="n">fl</span><span class="o">+</span>\
                                     <span class="s2">&quot; Expected a time-series of length &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tlens</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span>
                                     <span class="s2">&quot;but actual length is &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ts_vec</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
                <span class="n">roi</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Safeguard: stop if subject is missing, i.e., `roi == 0` still (weirder things have happened...)</span>
        <span class="k">if</span> <span class="n">roi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Subject &quot;</span><span class="o">+</span><span class="n">sublist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; is missing!&quot;</span><span class="p">)</span>

        <span class="c1"># Safeguard: stop if subject hast more/fewer ROIs than expected</span>
        <span class="k">elif</span> <span class="n">roi</span> <span class="o">!=</span> <span class="n">numregs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">roi</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot; time-series for subject &quot;</span><span class="o">+</span><span class="n">sublist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;, expected &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numregs</span><span class="p">)))</span>

    <span class="c1"># Check the lengths of the detected time-series</span>
    <span class="k">if</span> <span class="n">tlens</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Time-series of Subject &#39;</span><span class="o">+</span><span class="n">sublist</span><span class="p">[</span><span class="n">tlens</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span><span class="o">+</span><span class="s1">&#39; is empty or has fewer than 2 entries!&#39;</span><span class="p">)</span>

    <span class="c1"># Allocate tensor to hold all time series</span>
    <span class="n">bigmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tlens</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">numregs</span><span class="p">,</span><span class="n">numsubs</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Allocate tensor holding statistical dependence matrices of all subjects </span>
    <span class="n">corrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numregs</span><span class="p">,</span><span class="n">numregs</span><span class="p">,</span><span class="n">numsubs</span><span class="p">))</span>

    <span class="c1"># Ready to do this...</span>
    <span class="nb">print</span> <span class="s2">&quot;Extracting data and calculating &quot;</span><span class="o">+</span><span class="n">corrtype</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot; coefficients&quot;</span>

    <span class="c1"># Cycle through subjects and save per-subject time series data column-wise</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
        <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">txtfiles</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fl</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                <span class="n">ts_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
                <span class="n">bigmat</span><span class="p">[:</span><span class="n">tlens</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">col</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts_vec</span>
                <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Compute statistical dependence based on corrtype</span>
        <span class="k">if</span> <span class="n">corrtype</span> <span class="o">==</span> <span class="s1">&#39;pearson&#39;</span><span class="p">:</span>
            <span class="n">corrs</span><span class="p">[:,:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">bigmat</span><span class="p">[:</span><span class="n">tlens</span><span class="p">[</span><span class="n">k</span><span class="p">],:,</span><span class="n">k</span><span class="p">],</span><span class="n">rowvar</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">corrtype</span> <span class="o">==</span> <span class="s1">&#39;mi&#39;</span><span class="p">:</span>
            <span class="n">corrs</span><span class="p">[:,:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mutual_info</span><span class="p">(</span><span class="n">bigmat</span><span class="p">[:</span><span class="n">tlens</span><span class="p">[</span><span class="n">k</span><span class="p">],:,</span><span class="n">k</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Happy breakdown</span>
    <span class="nb">print</span> <span class="s2">&quot;Done&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;corrs&#39;</span><span class="p">:</span><span class="n">corrs</span><span class="p">,</span> <span class="s1">&#39;bigmat&#39;</span><span class="p">:</span><span class="n">bigmat</span><span class="p">,</span> <span class="s1">&#39;sublist&#39;</span><span class="p">:</span><span class="n">sublist</span><span class="p">}</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="corrcheck"><a class="viewcode-back" href="../_stubs/nws_tools.corrcheck.html#nws_tools.corrcheck">[docs]</a><span class="k">def</span> <span class="nf">corrcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sanity checks for statistical dependence matrices</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Dynamic : Usage as follows</span>
<span class="sd">    corrcheck(A) : input is NumPy 2darray                    </span>
<span class="sd">        shows some statistics for the statistical dependence matrix `A`</span>
<span class="sd">    corrcheck(A,label) : input is NumPy 2darray and `[&#39;string&#39;]`</span>
<span class="sd">        shows some statistics for the matrix `A` and uses</span>
<span class="sd">        `label`, a list containing one string, as title in figures. </span>
<span class="sd">    corrcheck(A,B,C,...) : input are many NumPy 2darrays            </span>
<span class="sd">        shows some statistics for the statistical dependence matrices `A`, `B`, `C`,....</span>
<span class="sd">    corrcheck(A,B,C,...,label) : input are many NumPy 2darrays and a list of strings      </span>
<span class="sd">        shows some statistics for the statistical dependence matrices `A`, `B`, `C`,....</span>
<span class="sd">        and uses the list of strings `label` to generate titles in figures. </span>
<span class="sd">        Note that `len(label)` has to be equal to the number of </span>
<span class="sd">        input matrices. </span>
<span class="sd">    corrcheck(T) : input is NumPy 3darray                    </span>
<span class="sd">        shows some statistics for statistical dependence matrices stored </span>
<span class="sd">        in the tensor `T`. The storage scheme has to be</span>
<span class="sd">                `T[:,:,0] = A`</span>

<span class="sd">                `T[:,:,1] = B`</span>

<span class="sd">                `T[:,:,2] = C`</span>

<span class="sd">                etc.</span>

<span class="sd">        where `A`, `B`, `C`,... are matrices. </span>
<span class="sd">    corrcheck(T,label) : input is NumPy 3darray and list of strings</span>
<span class="sd">        shows some statistics for matrices stored </span>
<span class="sd">        in the tensor `T`. The storage scheme has to be</span>
<span class="sd">                `T[:,:,0] = A`</span>

<span class="sd">                `T[:,:,1] = B`</span>

<span class="sd">                `T[:,:,2] = C`</span>

<span class="sd">                etc.</span>

<span class="sd">        where `A`, `B`, `C`,... are matrices. The list of strings `label`</span>
<span class="sd">        is used to generate titles in figures. Note that `len(label)`</span>
<span class="sd">        has to be equal to `T.shape[2]`</span>
<span class="sd">    corrcheck(...,title=&#39;mytitle&#39;) : input is any of the above</span>
<span class="sd">        same as above and and uses the string `mytitle` as window name for figures. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing : None</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Plotting params used later (max. #plots per row)</span>
    <span class="n">cplot</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># Sanity checks</span>
    <span class="n">myin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">myin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one input required!&#39;</span><span class="p">)</span>

    <span class="c1"># Assign global name for all figures if provided by additional keyword argument `title`</span>
    <span class="n">figtitle</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">);</span> <span class="n">nofigname</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">figtitle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">nofigname</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">figtitle</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Figure title must be a string!&#39;</span><span class="p">)</span>

    <span class="c1"># If labels have been provided, extract them now</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],(</span><span class="nb">list</span><span class="p">)):</span>
        <span class="n">myin</span>  <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">usrlbl</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="n">myin</span>  <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">usrlbl</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usrlbl</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Try to get shape of input</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">szin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected NumPy array(s) as input, found &quot;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s2">&quot;!&quot;</span><span class="p">)</span>

    <span class="c1"># If input is a list of matrices, store them in a tensor</span>
    <span class="k">if</span> <span class="n">szin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">rw</span><span class="p">,</span><span class="n">cl</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">!=</span> <span class="n">cl</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input matrices must be square!&#39;</span><span class="p">)</span>
        <span class="n">corrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rw</span><span class="p">,</span><span class="n">cl</span><span class="p">,</span><span class="n">myin</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">myin</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">corrs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All input matrices have to be of the same size!&#39;</span><span class="p">)</span>

    <span class="c1"># If input is a tensor, there&#39;s not much to do  </span>
    <span class="k">elif</span> <span class="n">szin</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">myin</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not more than one input tensor supported!&#39;</span><span class="p">)</span>
        <span class="n">shv</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">shv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">shv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">shv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">shv</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input tensor must be of the format N-by-N-by-k!&#39;</span><span class="p">)</span>
        <span class="n">corrs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input has to be either a matrix/matrices or a tensor!&#39;</span><span class="p">)</span>

    <span class="c1"># Count number of matrices and get their dimension</span>
    <span class="n">nmat</span> <span class="o">=</span> <span class="n">corrs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">N</span>    <span class="o">=</span> <span class="n">corrs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Check if those matrices are real and &quot;reasonable&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input arrays must be real-valued!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All matrices must be real without NaNs or Infs!&quot;</span><span class="p">)</span>

    <span class="c1"># Check if we&#39;re dealing with Pearson or NMI matrices (or something completely unexpected)</span>
    <span class="n">cmin</span> <span class="o">=</span> <span class="n">corrs</span><span class="o">.</span><span class="n">min</span><span class="p">();</span> <span class="n">cmax</span> <span class="o">=</span> <span class="n">corrs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cmax</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">cmin</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;WARNING: Input has to have values between -1/+1 or 0/+1. Found &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cmin</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; to &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cmax</span><span class="p">)</span>
        <span class="nb">print</span> <span class="n">msg</span>
    <span class="n">maxval</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">corrs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># If labels have been provided, check if we got enough of&#39;em; if there are no labels, generate defaults</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">usrlbl</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nmat</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Numbers of labels and matrices do not match up!&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lb</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lb</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Labels must be provided as list of strings or a single string!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Matrix &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nmat</span><span class="p">)]</span>

    <span class="c1"># Set subplot params and turn on interactive plotting</span>
    <span class="n">rplot</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nmat</span><span class="o">/</span><span class="n">cplot</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">nmat</span> <span class="o">&lt;=</span> <span class="n">cplot</span><span class="p">:</span> <span class="n">cplot</span> <span class="o">=</span> <span class="n">nmat</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>

    <span class="c1"># Now let&#39;s actually do something and plot the statistical dependence matrices (show warning matrix if is not symmetric)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">nofigname</span><span class="p">:</span> <span class="n">figtitle</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">get_window_title</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="n">figtitle</span><span class="o">+</span><span class="s1">&#39;: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; Nodes&#39;</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nmat</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">rplot</span><span class="p">,</span><span class="n">cplot</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">corrs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">minval</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">maxval</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">issym</span><span class="p">(</span><span class="n">corrs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;WARNING: &quot;</span><span class="o">+</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; is not symmetric!&quot;</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
    <span class="n">cbar_ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cbar_ax</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

    <span class="c1"># Plot statistical dependence histograms</span>
    <span class="n">meanval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">minval</span><span class="p">,</span><span class="n">maxval</span><span class="p">])</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)),</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">NN</span>  <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">nofigname</span><span class="p">:</span> <span class="n">figtitle</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">get_window_title</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="n">figtitle</span><span class="o">+</span><span class="s1">&#39;: &#39;</span><span class="o">+</span><span class="s2">&quot;Statistical Dependence Histograms&quot;</span><span class="p">)</span>
    <span class="n">bars</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">ylims</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nmat</span><span class="p">):</span>
        <span class="n">cvec</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
        <span class="p">[</span><span class="n">corrcount</span><span class="p">,</span><span class="n">corrbins</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">cvec</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="n">minval</span><span class="p">,</span><span class="n">maxval</span><span class="p">))</span>
        <span class="n">bars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">rplot</span><span class="p">,</span><span class="n">cplot</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">corrbins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">corrcount</span><span class="o">/</span><span class="n">NN</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">corrbins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">corrbins</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">ylims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bars</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">minval</span><span class="p">,</span><span class="n">maxval</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">((</span><span class="n">minval</span><span class="p">,</span><span class="n">meanval</span><span class="p">,</span><span class="n">maxval</span><span class="p">),(</span><span class="nb">str</span><span class="p">(</span><span class="n">minval</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">meanval</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">maxval</span><span class="p">)))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">cplot</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ylims</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">mybar</span> <span class="ow">in</span> <span class="n">bars</span><span class="p">:</span> <span class="n">mybar</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="n">ymax</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

    <span class="c1"># Show negative correlations (for Pearson matrices)</span>
    <span class="k">if</span> <span class="n">minval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nofigname</span><span class="p">:</span> <span class="n">figtitle</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">get_window_title</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="n">figtitle</span><span class="o">+</span><span class="s1">&#39;: &#39;</span><span class="o">+</span><span class="s2">&quot;Negative Correlations Are BLACK&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nmat</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">rplot</span><span class="p">,</span><span class="n">cplot</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">((</span><span class="n">corrs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span><span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

    <span class="c1"># Diversity</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">nofigname</span><span class="p">:</span> <span class="n">figtitle</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">get_window_title</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="n">figtitle</span><span class="o">+</span><span class="s1">&#39;: &#39;</span><span class="o">+</span><span class="s2">&quot;Diversity of Statistical Dependencies&quot;</span><span class="p">)</span>
    <span class="n">xsteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">stems</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">ylims</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nmat</span><span class="p">):</span>
        <span class="n">stems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">rplot</span><span class="p">,</span><span class="n">cplot</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">varc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">corrs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">xsteps</span><span class="p">,</span><span class="n">varc</span><span class="p">)</span>
        <span class="n">ylims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stems</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">),(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ylims</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">mystem</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span> <span class="n">mystem</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="n">ymax</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="get_meannw"><a class="viewcode-back" href="../_stubs/nws_tools.get_meannw.html#nws_tools.get_meannw">[docs]</a><span class="k">def</span> <span class="nf">get_meannw</span><span class="p">(</span><span class="n">nws</span><span class="p">,</span><span class="n">percval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to compute group-averaged networks</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nws : NumPy 3darray</span>
<span class="sd">        `N`-by-`N` connection matrices of `numsubs` subjects. Format is `nws.shape = (N,N,numsubs)` </span>
<span class="sd">        such that `nws[:,:,i] = N x N` connection matrix of `i`-th subject </span>
<span class="sd">    percval : float</span>
<span class="sd">        Percentage value, such that connections not present in at least `percval`</span>
<span class="sd">        percent of subjects are not considered, thus `0 &lt;= percval &lt;= 1`.</span>
<span class="sd">        Default setting is `percval = 0.0`</span>
<span class="sd">       </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mean_wghted : NumPy 2darray</span>
<span class="sd">        `N`-by-`N` mean value matrix of `numsubs` matrices stored in `nws` where</span>
<span class="sd">        only connections present in at least `percval` percent of subjects</span>
<span class="sd">        are considered</span>
<span class="sd">    percval : float</span>
<span class="sd">        Percentage value used to generate `mean_wghted`</span>
<span class="sd">       </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the current setting of `percval` leads to a disconnected network, </span>
<span class="sd">    the code increases `percval` in 5% steps to ensure connectedness of the group-averaged graph. </span>
<span class="sd">    The concept of using only a certain percentage of edges present in subjects was taken from [1]_. </span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    None</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. van den Heuvel, O. Sporns. Rich-Club Organization of the Human Connectome. </span>
<span class="sd">           J. Neurosci, 31(44) 15775-15786, 2011. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">nws</span><span class="p">,</span><span class="s1">&#39;tensor&#39;</span><span class="p">,</span><span class="s1">&#39;nws&#39;</span><span class="p">)</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">percval</span><span class="p">,</span><span class="s1">&#39;percval&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Get shape of input tensor</span>
    <span class="n">N</span>       <span class="o">=</span> <span class="n">nws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">numsubs</span> <span class="o">=</span> <span class="n">nws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Remove self-connections</span>
    <span class="n">nws</span> <span class="o">=</span> <span class="n">rm_selfies</span><span class="p">(</span><span class="n">nws</span><span class="p">)</span>

    <span class="c1"># Allocate memory for binary/weighted group averaged networks</span>
    <span class="n">mean_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
    <span class="n">mean_wghted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

    <span class="c1"># Compute mean network and keep increasing `percval` until we get a connected mean network</span>
    <span class="n">docalc</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">docalc</span><span class="p">:</span>

        <span class="c1"># Reset matrices </span>
        <span class="n">mean_binary</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mean_wghted</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Cycle through subjects to compute average network</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
            <span class="n">mean_binary</span> <span class="o">=</span> <span class="n">mean_binary</span> <span class="o">+</span> <span class="p">(</span><span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">mean_wghted</span> <span class="o">=</span> <span class="n">mean_wghted</span> <span class="o">+</span> <span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Kick out connections not present in at least `percval%` of subjects (in binary and weighted NWs)</span>
        <span class="n">mean_binary</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_binary</span><span class="o">/</span><span class="n">numsubs</span> <span class="o">&gt;=</span> <span class="n">percval</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">mean_wghted</span> <span class="o">=</span> <span class="n">mean_wghted</span><span class="o">/</span><span class="n">numsubs</span> <span class="o">*</span> <span class="n">mean_binary</span>

        <span class="c1"># Check connectedness of mean network</span>
        <span class="k">if</span> <span class="n">degrees_und</span><span class="p">(</span><span class="n">mean_binary</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;WARNING: Mean network disconnected for percval = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">percval</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>
            <span class="k">if</span> <span class="n">percval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;Decreasing percval by 5%...&quot;</span>
                <span class="n">percval</span> <span class="o">-=</span> <span class="mf">0.05</span>
                <span class="nb">print</span> <span class="s2">&quot;New value for percval is now &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">percval</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Mean network disconnected for percval = 0%. That means at least one node is &quot;</span><span class="o">+</span>\
                      <span class="s2">&quot;disconnected in ALL per-subject networks...&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">docalc</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">mean_wghted</span><span class="p">,</span> <span class="n">percval</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="rm_negatives"><a class="viewcode-back" href="../_stubs/nws_tools.rm_negatives.html#nws_tools.rm_negatives">[docs]</a><span class="k">def</span> <span class="nf">rm_negatives</span><span class="p">(</span><span class="n">corrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove negative entries from connection matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    corrs : NumPy 3darray</span>
<span class="sd">        An array of `K` matrices of dimension `N`-by-`N`. Format is `corrs.shape = (N,N,K)`,</span>
<span class="sd">        such that `corrs[:,:,i]` is the `i`-th `N x N` matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nws : NumPy 3darray</span>
<span class="sd">        Same format as input tensor but `corrs &gt;= 0`. </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span><span class="s1">&#39;tensor&#39;</span><span class="p">,</span><span class="s1">&#39;corrs&#39;</span><span class="p">)</span>

    <span class="c1"># See how many matrices are stacked in the array</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">corrs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Zero diagonals of matrices</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">corrs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Remove negative entries</span>
    <span class="n">nws</span> <span class="o">=</span> <span class="p">(</span><span class="n">corrs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">corrs</span>

    <span class="c1"># Check if we lost some nodes...</span>
    <span class="n">ndnum</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">corrs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">degrees_und</span><span class="p">(</span><span class="n">corrs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">deg</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">badidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">deg</span><span class="o">==</span><span class="n">deg</span><span class="o">.</span><span class="n">min</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">print</span> <span class="s2">&quot;WARNING: In network &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; a total of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">badidx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; out of &quot;</span><span class="o">+</span><span class="n">ndnum</span><span class="o">+</span>\
                <span class="s2">&quot; node(s) got disconnected, namely vertices #&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">badidx</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nws</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="rm_selfies"><a class="viewcode-back" href="../_stubs/nws_tools.rm_selfies.html#nws_tools.rm_selfies">[docs]</a><span class="k">def</span> <span class="nf">rm_selfies</span><span class="p">(</span><span class="n">conns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove self-connections from connection matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    conns : NumPy 3darray</span>
<span class="sd">        An array of `K` connection matrices of dimension `N`-by-`N`. Format is `conns.shape = (N,N,K)`,</span>
<span class="sd">        such that `conns[:,:,i]` is the `i`-th `N x N` connection matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nws : NumPy 3darray</span>
<span class="sd">        Same format as input array but `np.diag(conns[:,:,k]).min() = 0.0`. </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    None</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">conns</span><span class="p">,</span><span class="s1">&#39;tensor&#39;</span><span class="p">,</span><span class="s1">&#39;conns&#39;</span><span class="p">)</span>

    <span class="c1"># Create output quantity and zero its diagonals</span>
    <span class="n">nws</span> <span class="o">=</span> <span class="n">conns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nws</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="thresh_nws"><a class="viewcode-back" href="../_stubs/nws_tools.thresh_nws.html#nws_tools.thresh_nws">[docs]</a><span class="k">def</span> <span class="nf">thresh_nws</span><span class="p">(</span><span class="n">nws</span><span class="p">,</span><span class="n">userdens</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">percval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">force_den</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">span_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Threshold networks based on connection density</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nws : NumPy 3darray</span>
<span class="sd">        Undirected `N`-by-`N` (un)weighted connection matrices of `numsubs` subjects. </span>
<span class="sd">        Format is `corrs.shape = (N,N,numsubs)` such that `corrs[:,:,i] = N x N` </span>
<span class="sd">        connection matrix of `i`-th subject </span>
<span class="sd">    userdens : int</span>
<span class="sd">        By default, the input networks are thresholded down to the lowest common </span>
<span class="sd">        connection density without disconnecting any nodes in the networks using </span>
<span class="sd">        a relative thresholding strategy (`force_den = False` and `span_tree = False`). </span>
<span class="sd">        If `userdens` is provided and `span_tree = False`, then `userdens`</span>
<span class="sd">        is used as target density in the relative thresholding strategy. However, </span>
<span class="sd">        if `userdens` is below the minimum density before networks fragment, </span>
<span class="sd">        it will not be used unless `force_den = True`. </span>
<span class="sd">        If `span_tree = True` and `userdens` is `None`, then maximum spanning </span>
<span class="sd">        trees will be returned for all input networks. If `userdens` is provided, </span>
<span class="sd">        the spanning trees will be populated with the strongest connections </span>
<span class="sd">        found in the original networks up to the desired edge density. </span>
<span class="sd">        For both relative thresholding and maximum spanning tree density reduction, </span>
<span class="sd">        `userdens` should be either `None` or an integer between 0 and 100. </span>
<span class="sd">        See Notes below for more details. </span>
<span class="sd">    percval : float</span>
<span class="sd">        Percentage value for computing mean network averaged across all thresholded </span>
<span class="sd">        graphs, such that connections not present in at least `percval`</span>
<span class="sd">        percent of subjects are not considered (`0 &lt;= percval &lt;= 1`).</span>
<span class="sd">        Default setting is `percval = 0.0`. See `get_meannw` for details. </span>
<span class="sd">    force_den : bool</span>
<span class="sd">        If `force_den = True` relative thresholding is applied to the networks </span>
<span class="sd">        until all graphs hit the desired density level defined by the user </span>
<span class="sd">        even if nodes get disconnected in the process. This argument has no </span>
<span class="sd">        effect if `span_tree = True`. By default, `force_den = False`. </span>
<span class="sd">    span_tree : bool</span>
<span class="sd">        If `span_tree` is `True` density reduction is performed by constructing maximum </span>
<span class="sd">        spanning trees. If `userdens` is `None`, only spanning trees for all input networks</span>
<span class="sd">        will be returned. If `userdens` is provided, spanning trees will be populated </span>
<span class="sd">        with the strongest connections found in the original networks up to the </span>
<span class="sd">        desired edge density. Note that `foce_den` is ignored if `span_tree` is `True`. </span>
<span class="sd">               </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dictionary holding computed quantities. The fields of the dictionary depend upon </span>
<span class="sd">    the values of the optional keyword arguments `userdens` and `span_tree`. </span>
<span class="sd">    res : dict </span>
<span class="sd">        Dictionary with fields</span>

<span class="sd">        th_nws : NumPy 3darray</span>
<span class="sd">            Sparse networks. Format is the same as for `nws` </span>
<span class="sd">            (Not returned if `userdens` is `None` and `span_tree = True`). </span>
<span class="sd">        den_values : NumPy 1darray</span>
<span class="sd">            Density values of the networks stored in `th_nws`, such that `den_values[i]`</span>
<span class="sd">            is the edge density of the graph `th_nws[:,:,i]`</span>
<span class="sd">            (not returned if `userdens` is `None` and `span_tree = True`). </span>
<span class="sd">        th_mnw : NumPy 2darray</span>
<span class="sd">            Mean network averaged across all sparse networks `th_nws` </span>
<span class="sd">            (not returned if `userdens` is `None` and `span_tree = True`). </span>
<span class="sd">        mnw_percval: float</span>
<span class="sd">            Percentage value used to compute `th_mnw` (see documentation of `get_meannw` for</span>
<span class="sd">            details, not returned if `userdens` is `None` and `span_tree = True`). </span>
<span class="sd">        tau_levels : NumPy 1darray</span>
<span class="sd">            Cutoff values used in the relative thresholding strategy to compute </span>
<span class="sd">            `th_nws`, i.e., `tau_levels[i]` is the threshold that generated </span>
<span class="sd">            network `th_nws[:,:,i]` (only returned if `span_tree = False`). </span>
<span class="sd">        nws_forest : NumPy 3darray</span>
<span class="sd">            Maximum spanning trees calculated for all input networks </span>
<span class="sd">            (only returned if `span_tree = True`). </span>
<span class="sd">        mean_tree : NumPy 2darray</span>
<span class="sd">            Mean spanning tree averaged across all spanning trees stored in </span>
<span class="sd">            `nws_forest` (only returned if `span_tree = True`). </span>
<span class="sd">        mtree_percval : float</span>
<span class="sd">            Percentage value used to compute `mean_tree` (see documentation of `get_meannw` for</span>
<span class="sd">            details, only returned if `span_tree = True`). </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This routine uses either a relative thresholding strategy or a maximum spanning tree </span>
<span class="sd">    approach to decrease the density of a given set of input networks. </span>

<span class="sd">    During relative thresholding (`span_tree = False`) edges are discarded based on their value relative to the </span>
<span class="sd">    maximum edge weight found across all networks beginning with the weakest links. By default, </span>
<span class="sd">    the thresholding algorithm uses the lowest common connection density across all input networks </span>
<span class="sd">    before a node is disconnected as target edge density. That means, if networks `A`, `B` and `C` </span>
<span class="sd">    can be thresholded down to 40%, 50% and 60% density, respectively, without disconnecting any </span>
<span class="sd">    nodes, then the lowest common density for thresholding `A`, `B` and `C` together is 60%. </span>
<span class="sd">    In this case the raw network `A` already has a density of 60% or lower, which is thus excluded </span>
<span class="sd">    from thresholding and the original network is copied into `th_nws`. If a density level </span>
<span class="sd">    is provided by the user, then the code tries to use it unless it violates connectedness </span>
<span class="sd">    of all thresholded networks - in this case the lowest common density of all networks is used, </span>
<span class="sd">    unless `force_den = True` which causes the code to employ the user-provided density level </span>
<span class="sd">    for thresholding, disconnecting nodes from the networks in the process. </span>

<span class="sd">    The maximum spanning tree approach (`span_tree = True`) can be interpreted as the inverse of relative </span>
<span class="sd">    thresholding. Instead of chipping away weak edges in the input networks until a target density </span>
<span class="sd">    is met (or nodes disconnect), a minimal backbone of the network is calculated and then </span>
<span class="sd">    populated with the strongest connections found in the original network until a desired </span>
<span class="sd">    edge density level is reached. The backbone of the network is calculated by computing the graph&#39;s maximum</span>
<span class="sd">    spanning tree, that connects all nodes with the minimum number of maximum-weight edges. </span>
<span class="sd">    Note, that unless each edge has a distinct unique weight value a graph has numerous different </span>
<span class="sd">    maximum spanning trees. Thus, the spanning trees computed by this routine are usually *not* unique, </span>
<span class="sd">    and consequently the thresholded networks may not be unique either (particularly for low </span>
<span class="sd">    density levels, for which the computed populated networks are very similar to the underlying spanning trees). </span>
<span class="sd">    Thus, in contrast to the more common relative thresholding strategy, this bottom-up approach </span>
<span class="sd">    allows to reduce a given network&#39;s density to an almost arbitrary level </span>
<span class="sd">    (&gt;= density of the maximum spanning tree) without disconnecting nodes. However, unlike relative </span>
<span class="sd">    thresholding, the computed sparse networks are not necessarily unique and strongly depend </span>
<span class="sd">    on the intial maximum spanning tree. Note that if `userdens` is `None`, only maximum spanning </span>
<span class="sd">    trees will be computed. </span>

<span class="sd">    The code below relies on the routine `get_meannw` in this module to compute the group-averaged</span>
<span class="sd">    network. Futher, maximum spanning trees are calculated using `backbone_wu.m` from the </span>
<span class="sd">    Brain Connectivity Toolbox (BCT) for MATLAB via Octave. Thus, it requires Octave to be installed </span>
<span class="sd">    with the BCT in its search path. Further, `oct2py` is needed to launch an Octave instance </span>
<span class="sd">    from within Python. </span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    get_meannw : Helper function to compute group-averaged networks</span>
<span class="sd">    backbone_wu : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                  `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">nws</span><span class="p">,</span><span class="s1">&#39;tensor&#39;</span><span class="p">,</span><span class="s1">&#39;nws&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">userdens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">userdens</span><span class="p">,</span><span class="s1">&#39;userdens&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">percval</span><span class="p">,</span><span class="s1">&#39;percval&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">force_den</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The optional argument `force_den` has to be Boolean!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">span_tree</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The optional argument `span_tree` has to be Boolean!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">force_den</span> <span class="ow">and</span> <span class="n">span_tree</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">WARNING: The flag `foce_den` has no effect if `span_tree == True`!&quot;</span>

    <span class="c1"># Try to import `octave` from `oct2py`</span>
    <span class="k">if</span> <span class="n">span_tree</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="kn">from</span> <span class="nn">oct2py</span> <span class="k">import</span> <span class="n">octave</span>
        <span class="k">except</span><span class="p">:</span> 
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Could not import octave from oct2py! &quot;</span><span class="o">+</span>\
                     <span class="s2">&quot;To compute the maximum spanning tree octave must be installed and in the search path. &quot;</span><span class="o">+</span>\
                     <span class="s2">&quot;Furthermore, the Brain Connectivity Toolbox (BCT) for MATLAB must be installed &quot;</span><span class="o">+</span>\
                     <span class="s2">&quot;in the octave search path. &quot;</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        
    <span class="c1"># Get dimension of per-subject networks</span>
    <span class="n">N</span>       <span class="o">=</span> <span class="n">nws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">numsubs</span> <span class="o">=</span> <span class="n">nws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Zero diagonals and check for symmetry</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">issym</span><span class="p">(</span><span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is not symmetric!&quot;</span><span class="p">)</span>

    <span class="c1"># Get max. and min. weights (min weight should be &gt;= 0 otherwise the stuff below makes no sense...)</span>
    <span class="n">maxw</span> <span class="o">=</span> <span class="n">nws</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">nws</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only non-negative weights supported!&#39;</span><span class="p">)</span>

    <span class="c1"># Allocate vector for original densities </span>
    <span class="n">raw_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numsubs</span><span class="p">,))</span>

    <span class="c1"># Compute densities of raw networks </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
        <span class="n">raw_den</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">density_und</span><span class="p">(</span><span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Compute min/max density in raw data</span>
    <span class="n">min_raw</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">raw_den</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span>
    <span class="n">max_raw</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">raw_den</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

    <span class="c1"># Break if a nw has density zero or if max. density is below desired dens.</span>
    <span class="k">if</span> <span class="n">min_raw</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Network &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">raw_den</span><span class="o">.</span><span class="n">argmin</span><span class="p">())</span><span class="o">+</span><span class="s1">&#39; has density 0%!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">userdens</span> <span class="o">&gt;=</span> <span class="n">max_raw</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;All networks have density lower than desired density &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">userdens</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>
        <span class="n">th_mnw</span><span class="p">,</span><span class="n">mnw_percval</span> <span class="o">=</span> <span class="n">get_meannw</span><span class="p">(</span><span class="n">nws</span><span class="p">,</span><span class="n">percval</span><span class="p">)</span>
        <span class="n">res_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;th_nws&#39;</span><span class="p">:</span><span class="n">nws</span><span class="p">,</span> <span class="s1">&#39;den_values&#39;</span><span class="p">:</span> <span class="n">raw_den</span><span class="p">,</span> \
                    <span class="s1">&#39;th_mnw&#39;</span><span class="p">:</span> <span class="n">th_mnw</span><span class="p">,</span> <span class="s1">&#39;mnw_percval&#39;</span><span class="p">:</span> <span class="n">mnw_percval</span><span class="p">}</span>

        <span class="c1"># The structure of `backbone_wu.m` requires *exact* symmetry...</span>
        <span class="k">if</span> <span class="n">span_tree</span><span class="p">:</span>
            <span class="n">nws_forest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nws</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
                <span class="n">mnw</span> <span class="o">=</span> <span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">mnw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">mnw</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>                              
                <span class="n">nws_forest</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">backbone_wu</span><span class="p">(</span><span class="n">mnw</span> <span class="o">+</span> <span class="n">mnw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">mean_tree</span><span class="p">,</span><span class="n">mtree_percval</span> <span class="o">=</span> <span class="n">get_meannw</span><span class="p">(</span><span class="n">nws_forest</span><span class="p">,</span><span class="n">percval</span><span class="p">)</span>
            <span class="n">res_dict</span><span class="p">[</span><span class="s1">&#39;nws_forest&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nws_forest</span>
            <span class="n">res_dict</span><span class="p">[</span><span class="s1">&#39;mean_tree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_tree</span>
            <span class="n">res_dict</span><span class="p">[</span><span class="s1">&#39;mtree_percval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtree_percval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_dict</span><span class="p">[</span><span class="s1">&#39;tau_levels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">res_dict</span> 

    <span class="c1"># Inform user about minimal/maximal density in raw data</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Raw data has following density values: </span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Minimal density: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">min_raw</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Maximal density: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">max_raw</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>

    <span class="c1"># Allocate space for output (needed for both regular thresholding and de-foresting)</span>
    <span class="n">th_nws</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nws</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">den_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numsubs</span><span class="p">,))</span>
    <span class="n">th_mnw</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

    <span class="c1"># Maximum spanning tree shenanigans</span>
    <span class="k">if</span> <span class="n">span_tree</span><span class="p">:</span>

        <span class="c1"># Allocate space for the spanning trees</span>
        <span class="n">nws_forest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nws</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># If no target density was provided, just compute trees and get out of here</span>
        <span class="k">if</span> <span class="n">userdens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Calculating maximum spanning trees...&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
                <span class="n">mnw</span> <span class="o">=</span> <span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">mnw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">mnw</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>                              
                <span class="n">nws_forest</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">backbone_wu</span><span class="p">(</span><span class="n">mnw</span> <span class="o">+</span> <span class="n">mnw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">mean_tree</span><span class="p">,</span><span class="n">mtree_percval</span> <span class="o">=</span> <span class="n">get_meannw</span><span class="p">(</span><span class="n">nws_forest</span><span class="p">,</span><span class="n">percval</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;nws_forest&#39;</span><span class="p">:</span> <span class="n">nws_forest</span><span class="p">,</span> <span class="s1">&#39;mean_tree&#39;</span><span class="p">:</span> <span class="n">mean_tree</span><span class="p">,</span> <span class="s1">&#39;mtree_percval&#39;</span><span class="p">:</span> <span class="n">mtree_percval</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># The edge density `d` of an undirected network is given by</span>
            <span class="c1">#           (1) `d = 2*K/(N**2 - N)`, </span>
            <span class="c1"># where `K` denotes the number of edges in the network. Thus, `K` can be approximated by</span>
            <span class="c1">#           (2) `N*avdg/2`,</span>
            <span class="c1"># with `avdg` denoting the average nodal degree in the graph (divide by two</span>
            <span class="c1"># to not count links twice (we have undirected links i &lt;-&gt; j, not i -&gt; j and j &lt;- i).</span>
            <span class="c1"># Thus, substituting (2) for `K` in (1) and re-arranging terms yields</span>
            <span class="c1"># `avdg = d*(N**2 - N)/N`. Thus, for a user-provided density value, we can compute</span>
            <span class="c1"># the associated average degree of the wanted target network as</span>
            <span class="n">avdg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">userdens</span><span class="o">/</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
            <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Reducing network densities to &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">userdens</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;% by inversely populating maximum spanning trees...&quot;</span>

            <span class="c1"># Use this average degree value to cut down input networks to desired density</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
                <span class="n">mnw</span>      <span class="o">=</span> <span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">mnw</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">mnw</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>                              
                <span class="n">raw_dper</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">raw_den</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">raw_dper</span> <span class="o">&lt;=</span> <span class="n">userdens</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s2">&quot;Density of raw network #&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">raw_dper</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%&quot;</span><span class="o">+</span>\
                        <span class="s2">&quot; which is already lower than thresholding density of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">userdens</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>
                    <span class="nb">print</span> <span class="s2">&quot;Returning original unthresholded network&quot;</span>
                    <span class="n">th_nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">den_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_den</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">nws_forest</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">backbone_wu</span><span class="p">(</span><span class="n">mnw</span> <span class="o">+</span> <span class="n">mnw</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nws_forest</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="n">th_nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">backbone_wu</span><span class="p">(</span><span class="n">mnw</span> <span class="o">+</span> <span class="n">mnw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">avdg</span><span class="p">)</span>
                    <span class="n">den_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">density_und</span><span class="p">(</span><span class="n">th_nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span>
            <span class="n">mean_tree</span><span class="p">,</span><span class="n">mtree_percval</span> <span class="o">=</span> <span class="n">get_meannw</span><span class="p">(</span><span class="n">nws_forest</span><span class="p">,</span><span class="n">percval</span><span class="p">)</span>

            <span class="c1"># Populate results dictionary with method-specific quantities</span>
            <span class="n">res_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nws_forest&#39;</span><span class="p">:</span> <span class="n">nws_forest</span><span class="p">,</span> <span class="s1">&#39;mean_tree&#39;</span><span class="p">:</span> <span class="n">mean_tree</span><span class="p">,</span> <span class="s1">&#39;mtree_percval&#39;</span><span class="p">:</span> <span class="n">mtree_percval</span><span class="p">}</span>

    <span class="c1"># Here the good ol&#39; relative weight thresholding</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Allocate space for thresholds</span>
        <span class="n">tau_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numsubs</span><span class="p">,))</span>

        <span class="c1"># Create vector of thresholds to iterate over</span>
        <span class="n">dt</span>      <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="n">threshs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># Cycle through subjects and threshold the connection matrices until a node disconnects</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">mnw</span> <span class="o">=</span> <span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">density_und</span><span class="p">(</span><span class="n">mnw</span><span class="p">)</span>

            <span class="c1"># Start with 1%-weight threshold and increase </span>
            <span class="k">for</span> <span class="n">th</span> <span class="ow">in</span> <span class="n">threshs</span><span class="p">:</span>

                <span class="c1"># Save old iterates</span>
                <span class="n">den_old</span> <span class="o">=</span> <span class="n">den</span>
                <span class="n">tau_old</span> <span class="o">=</span> <span class="n">tau</span>
                <span class="n">mnw_old</span> <span class="o">=</span> <span class="n">mnw</span>

                <span class="c1"># Threshold based on percentage of max. weight: throw out all weights &lt; than 1%-max. weight, 2%, ...</span>
                <span class="c1"># Thin out connection matrix step by step (that&#39;s why we only have to load `nws[:,:,i]` once</span>
                <span class="n">tau</span> <span class="o">=</span> <span class="n">th</span><span class="o">*</span><span class="n">maxw</span>
                <span class="n">mnw</span> <span class="o">=</span> <span class="n">mnw</span><span class="o">*</span><span class="p">(</span><span class="n">mnw</span> <span class="o">&gt;=</span> <span class="n">tau</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

                <span class="c1"># Compute density of thinned graph (weight info is discarded)</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">density_und</span><span class="p">(</span><span class="n">mnw</span><span class="p">)</span>

                <span class="c1"># Compute nodal degrees of network </span>
                <span class="n">deg</span> <span class="o">=</span> <span class="n">degrees_und</span><span class="p">(</span><span class="n">mnw</span><span class="p">)</span>

                <span class="c1"># As soon as one node gets disconnected (i.e. `deg[i] == 0`) stop thresholding and save previous dens</span>
                <span class="k">if</span> <span class="n">deg</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">th_nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mnw_old</span>
                    <span class="n">tau_levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau_old</span>
                    <span class="n">den_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">den_old</span>
                    <span class="k">break</span>

        <span class="c1"># Compute minimal density before fragmentation across all subjects</span>
        <span class="n">densities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">den_values</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Minimal admissible densities of per-subject networks are as follows: &quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">densities</span><span class="o">.</span><span class="n">size</span><span class="p">):</span> <span class="nb">print</span> <span class="s2">&quot;Subject #&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">densities</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>
        <span class="n">min_den</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">den_values</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Thus, minimal density before fragmentation across all subjects is &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">min_den</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>

        <span class="c1"># Assign thresholding density level</span>
        <span class="k">if</span> <span class="n">userdens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thresh_dens</span> <span class="o">=</span> <span class="n">min_den</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">userdens</span> <span class="o">&lt;</span> <span class="n">min_den</span> <span class="ow">and</span> <span class="n">force_den</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">User provided density of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">userdens</span><span class="p">))</span><span class="o">+</span>\
                    <span class="s2">&quot;</span><span class="si">% lo</span><span class="s2">wer than minimal admissible density of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">min_den</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%. &quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;Using minimal admissible density instead. &quot;</span>
                <span class="n">thresh_dens</span> <span class="o">=</span> <span class="n">min_den</span>
            <span class="k">elif</span> <span class="n">userdens</span> <span class="o">&lt;</span> <span class="n">min_den</span> <span class="ow">and</span> <span class="n">force_den</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">WARNING: Provided density of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">userdens</span><span class="p">))</span><span class="o">+</span>\
                    <span class="s2">&quot;</span><span class="si">% le</span><span class="s2">ads to disconnected networks - proceed with caution...&quot;</span>
                <span class="n">thresh_dens</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">userdens</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">thresh_dens</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">userdens</span><span class="p">)</span>

        <span class="c1"># Inform the user about what&#39;s gonna happen </span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Using density of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">thresh_dens</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;%. Starting thresholding procedure...</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># Backtracking parameter</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.3</span>

        <span class="c1"># Cycle through subjects</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numsubs</span><span class="p">):</span>

            <span class="n">den_perc</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="n">th</span>       <span class="o">=</span> <span class="o">-</span><span class="n">dt</span>
            <span class="n">mnw</span>      <span class="o">=</span> <span class="n">nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">raw_dper</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">raw_den</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">raw_dper</span> <span class="o">&lt;=</span> <span class="n">thresh_dens</span><span class="p">:</span>

                <span class="nb">print</span> <span class="s2">&quot;Density of raw network #&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">raw_dper</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%&quot;</span><span class="o">+</span>\
                    <span class="s2">&quot; which is already lower than thresholding density of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">thresh_dens</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;%&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;Returning original unthresholded network&quot;</span>
                <span class="n">th_nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mnw</span>
                <span class="n">tau_levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">den_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_den</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">while</span> <span class="n">den_perc</span> <span class="o">&gt;</span> <span class="n">thresh_dens</span><span class="p">:</span>

                    <span class="n">th</span>  <span class="o">+=</span> <span class="n">dt</span>
                    <span class="n">tau</span> <span class="o">=</span> <span class="n">th</span><span class="o">*</span><span class="n">maxw</span>
                    <span class="n">mnw</span> <span class="o">=</span> <span class="n">mnw</span><span class="o">*</span><span class="p">(</span><span class="n">mnw</span> <span class="o">&gt;=</span> <span class="n">tau</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

                    <span class="n">den</span>      <span class="o">=</span> <span class="n">density_und</span><span class="p">(</span><span class="n">mnw</span><span class="p">)</span>
                    <span class="n">den_perc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">den</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">den_perc</span> <span class="o">&lt;</span> <span class="n">thresh_dens</span><span class="p">:</span>
                        <span class="n">th</span> <span class="o">*=</span> <span class="n">beta</span>

                <span class="n">th_nws</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mnw</span>
                <span class="n">tau_levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
                <span class="n">den_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">den</span>

        <span class="c1"># Populate results dictionary with method-specific quantities</span>
        <span class="n">res_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tau_levels&#39;</span><span class="p">:</span> <span class="n">tau_levels</span><span class="p">}</span>

    <span class="c1"># Compute group average network</span>
    <span class="n">th_mnw</span><span class="p">,</span><span class="n">mnw_percval</span> <span class="o">=</span> <span class="n">get_meannw</span><span class="p">(</span><span class="n">th_nws</span><span class="p">,</span><span class="n">percval</span><span class="p">)</span>

    <span class="c1"># Fill up results dictionary</span>
    <span class="n">res_dict</span><span class="p">[</span><span class="s1">&#39;th_nws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">th_nws</span>
    <span class="n">res_dict</span><span class="p">[</span><span class="s1">&#39;den_values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">den_values</span>
    <span class="n">res_dict</span><span class="p">[</span><span class="s1">&#39;th_mnw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">th_mnw</span>
    <span class="n">res_dict</span><span class="p">[</span><span class="s1">&#39;mnw_percval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mnw_percval</span>
    
    <span class="c1"># Be polite and dismiss the user </span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Done...</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">res_dict</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="normalize"><a class="viewcode-back" href="../_stubs/nws_tools.normalize.html#nws_tools.normalize">[docs]</a><span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-scales a NumPy ndarray</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : NumPy ndarray</span>
<span class="sd">        An array of size &gt; 1 (shape can be arbitrary)</span>
<span class="sd">    vmin : float</span>
<span class="sd">        Floating point number representing the lower normalization bound. </span>
<span class="sd">        (Note that it has to hold that `vmin &lt; vmax`)</span>
<span class="sd">    vmin : float</span>
<span class="sd">        Floating point number representing the upper normalization bound. </span>
<span class="sd">        (Note that it has to hold that `vmin &lt; vmax`)</span>
<span class="sd">       </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arrn : NumPy ndarray</span>
<span class="sd">        Scaled version of the input array `arr`, such that `arrn.min() == vmin` and </span>
<span class="sd">        `arrn.max() == vmax`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In contrast to Matplotlib&#39;s `Normalize`, *all* values of the input array are re-scaled, </span>
<span class="sd">    even if outside the specified bounds. For instance, if `arr.min() == -1` and `arr.max() == 0.5` then</span>
<span class="sd">    calling normalize with bounds `vmin = 0` and `vmax = 1` will result in an array `arrn`</span>
<span class="sd">    satisfying `arrn.min() == 0` and `arrn.max() == 1`. </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = array([[-1,.2],[100,0]])</span>
<span class="sd">    &gt;&gt;&gt; arrn = normalize(arr,vmin=-10,vmax=12)</span>
<span class="sd">    &gt;&gt;&gt; arrn </span>
<span class="sd">    array([[-10.        ,  -9.73861386],</span>
<span class="sd">           [ 12.        , -10.        ]])</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    None </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure that `arr` is a NumPy-ndarray</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input `arr` has to be a NumPy ndarray!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `arr` has to be a NumPy ndarray of size &gt; 1!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input array hast to be real-valued!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input `arr` must be real-valued without Inf&#39;s or NaN&#39;s!&quot;</span><span class="p">)</span>

    <span class="c1"># If normalization bounds are user specified, check them</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span><span class="s1">&#39;vmin&#39;</span><span class="p">)</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span><span class="s1">&#39;vmax&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vmax</span> <span class="o">&lt;=</span> <span class="n">vmin</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lower bound `vmin` has to be strictly smaller than upper bound `vmax`!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">vmin</span> <span class="o">-</span> <span class="n">vmax</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bounds too close: `|vmin - vmax| &lt; eps`, no normalization possible&#39;</span><span class="p">)</span>

    <span class="c1"># Get min and max of array</span>
    <span class="n">arrmin</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">arrmax</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># If min and max values of array are identical do nothing, if they differ close to machine precision abort</span>
    <span class="k">if</span> <span class="n">arrmin</span> <span class="o">==</span> <span class="n">arrmax</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">arrmin</span> <span class="o">-</span> <span class="n">arrmax</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Minimal and maximal values of array too close, no normalization possible&#39;</span><span class="p">)</span>

    <span class="c1"># Return normalized array</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="n">arrmin</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">arrmax</span> <span class="o">-</span> <span class="n">arrmin</span><span class="p">)</span> <span class="o">+</span> <span class="n">vmin</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="csv2dict"><a class="viewcode-back" href="../_stubs/nws_tools.csv2dict.html#nws_tools.csv2dict">[docs]</a><span class="k">def</span> <span class="nf">csv2dict</span><span class="p">(</span><span class="n">csvfile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads 3D nodal coordinates of from a csv file into a Python dictionary</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    csvfile : str</span>
<span class="sd">        File-name of (or full path to) the csv file holding the nodal coordinates.</span>
<span class="sd">        The format of this file HAS to be </span>

<span class="sd">                 `x, y, z` </span>

<span class="sd">                 `x, y, z` </span>

<span class="sd">                 `x, y, z` </span>

<span class="sd">                 .</span>

<span class="sd">                 .</span>

<span class="sd">        for each node. Thus `#rows = #nodes`. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mydict : dict</span>
<span class="sd">        Nodal coordinates as read from the input csv file. Format is</span>

<span class="sd">                `{0: (x, y, z),`</span>

<span class="sd">                `{1: (x, y, z),`</span>

<span class="sd">                `{2: (x, y, z),`</span>

<span class="sd">                 .</span>

<span class="sd">                 .</span>

<span class="sd">        Thus the dictionary has `#nodes` keys. </span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    None </span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    None </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure `csvfile` makes sense</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">csvfile</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Name of csv-file has to be a string!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">csvfile</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">csvfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">csvfile</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">csvfile</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;File: &#39;</span><span class="o">+</span><span class="n">csvfile</span><span class="o">+</span><span class="s1">&#39; does not exist!&#39;</span><span class="p">)</span>
    
    <span class="c1"># Open `csvfile`</span>
    <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">csvfile</span><span class="p">,</span><span class="s1">&#39;rU&#39;</span><span class="p">)</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Read nodal coordinates using csv module</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="s1">&#39;excel&#39;</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
    
    <span class="c1"># Iterate through rows and convert coordinates from string lists to float tuples</span>
    <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">mydict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">mydict</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="shownet"><a class="viewcode-back" href="../_stubs/nws_tools.shownet.html#nws_tools.shownet">[docs]</a><span class="k">def</span> <span class="nf">shownet</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="n">colorvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sizevec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">threshs</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">8</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">lwdths</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">],</span><span class="n">nodecmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span><span class="n">edgecmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span><span class="n">textscale</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a network in 3D using Mayavi</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : NumPy 2darray</span>
<span class="sd">        Square `N`-by-`N` connection matrix of the network</span>
<span class="sd">    coords: dict</span>
<span class="sd">        Nodal coordinates of the graph. Format is</span>

<span class="sd">                `{0: (x, y, z),`</span>

<span class="sd">                `{1: (x, y, z),`</span>

<span class="sd">                `{2: (x, y, z),`</span>

<span class="sd">                 .</span>

<span class="sd">                 .</span>

<span class="sd">        Note that the dictionary has to have `N` keys. </span>
<span class="sd">    colorvec : NumPy 1darray</span>
<span class="sd">        Vector of color-values for each node. This could be nodal strength or modular information of nodes </span>
<span class="sd">        (i.e., to which module does node `i` belong to). Thus `colorvec` has to be of length `N` and all its</span>
<span class="sd">        components must be in `[0,1]`. </span>
<span class="sd">    sizevec : NumPy 1darray </span>
<span class="sd">        Vector of nodal sizes. This could be degree, centrality, etc. Thus `sizevec` has to be of length </span>
<span class="sd">        `N` and all its components must be `&gt;= 0`. </span>
<span class="sd">    labels : list or NumPy 1darray</span>
<span class="sd">        Nodal labels. Format is `[&#39;Name1&#39;,&#39;Name2&#39;,&#39;Name3&#39;,...]` where the ordering HAS to be the same</span>
<span class="sd">        as in the `coords` dictionary. Note that the list/array has to have length `N`. </span>
<span class="sd">    threshs : list or NumPy 1darray</span>
<span class="sd">        Thresholds for visualization. Edges with weights larger than `threshs[0]` are drawn </span>
<span class="sd">        thickest, weights `&gt; threshs[1]` are thinner and so on. Note that if `threshs[-1]&gt;0` not all </span>
<span class="sd">        edges of the network are plotted (since edges with `0 &lt; weight &lt; threshs[-1]` will be ignored). </span>
<span class="sd">    lwdths : list or NumPy 1darray</span>
<span class="sd">        Line-widths associated to the thresholds provided by `threshs`. Edges with weights larger than </span>
<span class="sd">        `threshs[0]` are drawn with line-width `lwdths[0]`, edges with `weights &gt; threshs[1]` </span>
<span class="sd">        have line-width `lwdths[1]` and so on. Thus `len(lwdths) == len(threshs)`. </span>
<span class="sd">    nodecmap : str </span>
<span class="sd">        Mayavi colormap to be used for plotting nodes. See Notes for details. </span>
<span class="sd">    edgecmap : str </span>
<span class="sd">        Mayavi colormap to be used for plotting edges. See Notes for details. </span>
<span class="sd">    textscale : float</span>
<span class="sd">        Scaling factor for labels (larger numbers -&gt; larger text)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing : None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A list of available colormaps in Mayavi is currently available </span>
<span class="sd">    `here &lt;http://docs.enthought.com/mayavi/mayavi/mlab_changing_object_looks.html&gt;`_. </span>
<span class="sd">    See the </span>
<span class="sd">    `Mayavi documentation &lt;http://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html&gt;`_</span>
<span class="sd">    for more info. </span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    show_nw : A Matplotlib based implementation with extended functionality (but MUCH slower rendering)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># For those lucky enough to have a running installation of Mayavi...</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">mayavi</span> <span class="k">import</span> <span class="n">mlab</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Mayavi could not be imported. You might want to try `show_nw`, a slower (but more feature &#39;</span>\
              <span class="o">+</span><span class="s1">&#39;rich) graph rendering routine based on Matplotlib.&#39;</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Make sure the adjacency/weighting matrix makes sense</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Check the coordinate dictionary</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The coordinates have to be provided as dictionary!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bad</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The coordinate dictionary has to have N keys!&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;All elements of the `coords` dictionary have to be lists/arrays!&#39;</span><span class="p">)</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">),</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;coordinates&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All elements of the coords dictionary have to be 3-dimensional!&#39;</span><span class="p">)</span>

    <span class="c1"># Check `colorvec` if provided, otherwise assign default value</span>
    <span class="k">if</span> <span class="n">colorvec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">colorvec</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;colorvec&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">colorvec</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`colorvec` has to have length `N`!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">colorvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span>

    <span class="c1"># Same for `sizevec`</span>
    <span class="k">if</span> <span class="n">sizevec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">sizevec</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;sizevec&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sizevec</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`sizevec` has to have length `N`!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sizevec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span>

    <span class="c1"># Check labels (if any provided)</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Nodal labels have to be provided as list/NumPy 1darray!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bad</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of nodes and labels does not match up!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lb</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lb</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Each individual label has to be a string type!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Check thresholds and linewidhts</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshs</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Visualization thresholds have to be provided as list/NumPy 1darray!&quot;</span><span class="p">)</span>
    <span class="n">threshs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">threshs</span><span class="p">)</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">threshs</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;threshs&#39;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">threshs</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lwdths</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Linewidths have to be provided as list/NumPy 1darray!&quot;</span><span class="p">)</span>
    <span class="n">lwdths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lwdths</span><span class="p">)</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">lwdths</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;lwdths&#39;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">lwdths</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of thresholds and linewidths does not match up!&quot;</span><span class="p">)</span>

    <span class="c1"># Make sure colormap definitions were given as strings</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodecmap</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Colormap for nodes has to be provided as string!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edgecmap</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Colormap for edges has to be provided as string!&quot;</span><span class="p">)</span>

    <span class="c1"># Check `textscale`</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">textscale</span><span class="p">,</span><span class="s1">&#39;textscale&#39;</span><span class="p">)</span>

    <span class="c1"># Now start to actually do something...</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">quiver3d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()]),</span>\
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()]),</span>\
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()]),</span>\
                        <span class="n">sizevec</span><span class="p">,</span><span class="n">sizevec</span><span class="p">,</span><span class="n">sizevec</span><span class="p">,</span><span class="n">scalars</span><span class="o">=</span><span class="n">colorvec</span><span class="p">,</span>\
                        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;sphere&#39;</span><span class="p">,</span><span class="n">colormap</span><span class="o">=</span><span class="n">nodecmap</span><span class="p">)</span>

    <span class="c1"># Coloring of the balls is based on the provided scalars </span>
    <span class="n">pts</span><span class="o">.</span><span class="n">glyph</span><span class="o">.</span><span class="n">color_mode</span> <span class="o">=</span> <span class="s1">&#39;color_by_scalar&#39;</span>

    <span class="c1"># Finally, center the glyphs on the data point</span>
    <span class="n">pts</span><span class="o">.</span><span class="n">glyph</span><span class="o">.</span><span class="n">glyph_source</span><span class="o">.</span><span class="n">glyph_source</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Cycle through threshold levels to generate different line-widths of networks </span>
    <span class="n">srcs</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">threshs</span><span class="p">)):</span>

        <span class="c1"># Generate empty lists to hold (x,y,z) data and color information</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">z</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Get matrix entries &gt; current threshold level</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshs</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">index</span> <span class="o">+=</span> <span class="n">b</span>

        <span class="c1"># Finally generate lines connecting dots</span>
        <span class="n">srcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">scalar_scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">s</span><span class="p">))</span>
        <span class="n">srcs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mlab_source</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">connections</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">stripper</span><span class="p">(</span><span class="n">srcs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">colormap</span><span class="o">=</span><span class="n">edgecmap</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="n">lwdths</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Label nodes if wanted</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
        <span class="n">mlab</span><span class="o">.</span><span class="n">text3d</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">scale</span><span class="o">=</span><span class="n">textscale</span><span class="p">)</span>

    <span class="k">return</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="show_nw"><a class="viewcode-back" href="../_stubs/nws_tools.show_nw.html#nws_tools.show_nw">[docs]</a><span class="k">def</span> <span class="nf">show_nw</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="n">colorvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sizevec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">nodecmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">),</span><span class="n">edgecmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">),</span><span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">nodes3d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">viewtype</span><span class="o">=</span><span class="s1">&#39;axial&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matplotlib-based plotting routine for networks</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : NumPy 2darray</span>
<span class="sd">        Square `N`-by-`N` connection matrix of the network</span>
<span class="sd">    coords: dict</span>
<span class="sd">        Nodal coordinates of the graph. Format is</span>

<span class="sd">                `{0: (x, y, z),`</span>

<span class="sd">                `{1: (x, y, z),`</span>

<span class="sd">                `{2: (x, y, z),`</span>

<span class="sd">                 .</span>

<span class="sd">                 .</span>

<span class="sd">        Note that the dictionary has to have `N` keys. </span>
<span class="sd">    colorvec : NumPy 1darray</span>
<span class="sd">        Vector of color-values for each node. This could be nodal strength or modular information of nodes </span>
<span class="sd">        (i.e., to which module does node i belong to). Thus `colorvec` has to be of length `N` and all its</span>
<span class="sd">        components must be in `[0,1]`. </span>
<span class="sd">    sizevec : NumPy 1darray </span>
<span class="sd">        Vector of nodal sizes. This could be degree, centrality, etc. Thus `sizevec` has to be of </span>
<span class="sd">        length `N` and all its components must be `&gt;= 0`. </span>
<span class="sd">    labels : list or NumPy 1darray</span>
<span class="sd">        Nodal labels. Format is `[&#39;Name1&#39;,&#39;Name2&#39;,&#39;Name3&#39;,...]` where the ordering HAS to be the same</span>
<span class="sd">        as in the `coords` dictionary. Note that the list/array has to have length `N`. </span>
<span class="sd">    nodecmap : Matplotlib colormap</span>
<span class="sd">        Colormap to use for plotting nodes</span>
<span class="sd">    edgecmap : Matplotlib colormap</span>
<span class="sd">        Colormap to use for plotting edges</span>
<span class="sd">    linewidths : NumPy 2darray</span>
<span class="sd">        Same format and nonzero-pattern as `A`. If no linewidhts are provided then the edge connecting </span>
<span class="sd">        nodes `v_i` and `v_j` is plotted using the linewidth `A[i,j]`. By specifying, e.g., </span>
<span class="sd">        `linewidhts = (1+A)**2`, the thickness of edges in the network-plot can be scaled. </span>
<span class="sd">    nodes3d : bool</span>
<span class="sd">        If `nodes3d=True` then nodes are plotted using 3d spheres in space (with `diameters = sizevec`). </span>
<span class="sd">        If `nodes3d=False` then the Matplotlib `scatter` function is used to plot nodes as flat </span>
<span class="sd">        2d disks (faster).</span>
<span class="sd">    viewtype : str</span>
<span class="sd">        Camera position, `viewtype` can be one of the following</span>

<span class="sd">                `axial (= axial_t)`       : Axial view from top down</span>

<span class="sd">                `axial_t`                 : Axial view from top down</span>

<span class="sd">                `axial_b`                 : Axial view from bottom up</span>

<span class="sd">                `sagittal (= sagittal_l)` : Sagittal view from left</span>

<span class="sd">                `sagittal_l`              : Sagittal view from left</span>

<span class="sd">                `sagittal_r`              : Sagittal view from right</span>

<span class="sd">                `coronal (= coronal_f)`   : Coronal view from front</span>

<span class="sd">                `coronal_f`               : Coronal view from front</span>

<span class="sd">                `coronal_b`               : Coronal view from back</span>

<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing : None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See Matplotlib&#39;s `mplot3d tutorial &lt;http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html&gt;`_</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    shownet : A Mayavi based implementation with less functionality but MUCH faster rendering</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check the graph&#39;s connection matrix</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Check the coordinate dictionary</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The coordinates have to be provided as dictionary!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bad</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The coordinate dictionary has to have N keys!&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;All elements of the coords dictionary have to be lists/arrays!&#39;</span><span class="p">)</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">),</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;coordinates&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All elements of the coords dictionary have to be 3-dimensional!&#39;</span><span class="p">)</span>

    <span class="c1"># Check `colorvec` if provided, otherwise assign default value</span>
    <span class="k">if</span> <span class="n">colorvec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">colorvec</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;colorvec&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">colorvec</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`colorvec` has to have length `N`!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">colorvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span>

    <span class="c1"># Same for `sizevec`</span>
    <span class="k">if</span> <span class="n">sizevec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">sizevec</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;sizevec&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sizevec</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`sizevec` has to have length `N`!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sizevec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span>

    <span class="c1"># Check labels (if any provided)</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Nodal labels have to be provided as list/NumPy 1darray!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bad</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of nodes and labels does not match up!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lb</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lb</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Each individual label has to be a string type!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Check the colormaps</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">nodecmap</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;LinearSegmentedColormap&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Nodal colormap has to be a Matplotlib colormap!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">edgecmap</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;LinearSegmentedColormap&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Edge colormap has to be a Matplotlib colormap!&#39;</span><span class="p">)</span>

    <span class="c1"># If no linewidths were provided, use the entries of `A` as to control edge thickness</span>
    <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span><span class="s1">&#39;linewidths&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ln</span><span class="p">,</span><span class="n">lm</span><span class="p">)</span> <span class="o">=</span> <span class="n">linewidths</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">linewidths</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linewidths must be provided as square array of the same dimension as the connection matrix!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">A</span>

    <span class="c1"># Make sure `nodes3d` is Boolean</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes3d</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The nodes3d flag has to be a Boolean variable!&#39;</span><span class="p">)</span>

    <span class="c1"># Check if `viewtype` is anything strange</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">viewtype</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Viewtype must be &#39;axial(_{t/b})&#39;, &#39;sagittal(_{l/r})&#39; or &#39;coronal(_{f/b})&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Turn on 3d projection</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Extract nodal x-, y-, and z-coordinates from the coords-dictionary</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

    <span class="c1"># Order matters here: FIRST plot connections, THEN nodes on top of connections (looks weird otherwise)</span>
    <span class="c1"># Cycle through the matrix and plot every single connection line-by-line (this is *really* slow)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]],[</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]],[</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">linewidths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">edgecmap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]))</span>

    <span class="c1"># Plot nodes (either 3d spheres or flat scatter points)</span>
    <span class="k">if</span> <span class="n">nodes3d</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">zs</span><span class="o">=</span><span class="n">z</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">sizevec</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">colorvec</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">nodecmap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span>      <span class="o">=</span> <span class="mi">20</span><span class="c1">#10</span>
        <span class="n">theta</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">phi</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cosphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span> <span class="n">cosphi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cosphi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sinth</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span> <span class="n">sinth</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sinth</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>    

        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">cosphi</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">cosphi</span><span class="p">,</span><span class="n">sinth</span><span class="p">)</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,)))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">sizevec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">rd</span><span class="o">*</span><span class="n">xx</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">rd</span><span class="o">*</span><span class="n">yy</span><span class="o">+</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">rd</span><span class="o">*</span><span class="n">zz</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>\
                            <span class="n">color</span> <span class="o">=</span> <span class="n">nodecmap</span><span class="p">(</span><span class="n">colorvec</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>\
                            <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Label nodes if wanted</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

    <span class="c1"># If `viewtype` was specified as &#39;axial&#39;, &#39;coronal&#39; or &#39;sagittal&#39; use default (top, front, left) viewtypes</span>
    <span class="k">if</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;axial&#39;</span><span class="p">:</span>
        <span class="n">viewtype</span> <span class="o">=</span> <span class="s1">&#39;axial_t&#39;</span>
    <span class="k">elif</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;sagittal&#39;</span> <span class="ow">or</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;sagital&#39;</span><span class="p">:</span>
        <span class="n">viewtype</span> <span class="o">=</span> <span class="s1">&#39;sagittal_l&#39;</span>
    <span class="k">elif</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;coronal&#39;</span><span class="p">:</span>
        <span class="n">viewtype</span> <span class="o">=</span> <span class="s1">&#39;coronal_f&#39;</span>

    <span class="c1"># Turn off axis (don&#39;t really mean anything in this context anyway...) and set up view</span>
    <span class="k">if</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;axial_t&#39;</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span><span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;axial_b&#39;</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=-</span><span class="mi">90</span><span class="p">,</span><span class="n">azim</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;coronal_f&#39;</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">azim</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;coronal_b&#39;</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">azim</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;sagittal_l&#39;</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">azim</span><span class="o">=</span><span class="mi">180</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">viewtype</span> <span class="o">==</span> <span class="s1">&#39;sagittal_r&#39;</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">azim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="nb">print</span> <span class="s2">&quot;WARNING: Unrecognized viewtype: &quot;</span><span class="o">+</span><span class="n">viewtype</span>
        <span class="nb">print</span> <span class="s2">&quot;Using default viewtype `axial` instead&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span><span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> </div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="generate_randnws"><a class="viewcode-back" href="../_stubs/nws_tools.generate_randnws.html#nws_tools.generate_randnws">[docs]</a><span class="k">def</span> <span class="nf">generate_randnws</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span><span class="n">rwr</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">rwr_max</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random networks given a(n) (un)signed (un)weighted (un)directed input network</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nw : NumPy 2darray</span>
<span class="sd">        Connection matrix of input network</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of random networks to generate (&gt; 1)</span>
<span class="sd">    method : str</span>
<span class="sd">        String specifying which method to use to randomize </span>
<span class="sd">        the input network. Currently supported options are </span>
<span class="sd">        `&#39;auto&#39;` (default), `&#39;null_model_und_sign&#39;`, `&#39;randmio_und&#39;`, `&#39;randmio_und_connected&#39;`, </span>
<span class="sd">        `&#39;null_model_dir_sign&#39;`, `&#39;randmio_dir&#39;`, `&#39;randmio_dir_connected&#39;`, </span>
<span class="sd">        `&#39;randmio_und_signed&#39;`, `&#39;randmio_dir_signed&#39;`, </span>
<span class="sd">        If `method = &#39;auto&#39;` then a randomization strategy is chosen based </span>
<span class="sd">        the the properties of the input network (directedness, edge-density, sign of </span>
<span class="sd">        edge weights). In case of very dense networks (density &gt; 75%) the `null_model`</span>
<span class="sd">        routines are used to at least shuffle the input network&#39;s edge weights. </span>
<span class="sd">    rwr : int</span>
<span class="sd">        Number of approximate rewirings per edge (default: 5). </span>
<span class="sd">    rwr_max : int</span>
<span class="sd">        Maximal number of rewirings per edge to enforce randomization (default: 10). </span>
<span class="sd">        Note that `rwr_max` has to be greater or equals than `rwr`. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rnws : NumPy 3darray</span>
<span class="sd">        Random networks based on input graph `nw`. Format is `rnws.shape = (N,N,M)`</span>
<span class="sd">        such that `rnws[:,:,m] = m-th N x N` random network</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This routine calls functions from the Brain Connectivity Toolbox (BCT) for MATLAB via Octave. </span>
<span class="sd">    Thus, it requires Octave to be installed with the BCT in its search path. Further, </span>
<span class="sd">    `oct2py` is needed to launch an Octave instance from within Python. </span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    randmio_und_connected : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                            `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    randmio_dir_connected : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                            `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    randmio_und : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                  `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    randmio_dir : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                  `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    randmio_und_signed : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                         `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    randmio_dir_signed : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                         `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    null_model_und_sign : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                          `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    null_model_dir_sign : in the Brain Connectivity Toolbox (BCT) for MATLAB, currently available </span>
<span class="sd">                          `here &lt;https://sites.google.com/site/bctnet/&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Try to import `octave` from `oct2py`</span>
    <span class="k">try</span><span class="p">:</span> 
        <span class="kn">from</span> <span class="nn">oct2py</span> <span class="k">import</span> <span class="n">octave</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Could not import octave from oct2py! &quot;</span><span class="o">+</span>\
                 <span class="s2">&quot;To use this routine octave must be installed and in the search path. &quot;</span><span class="o">+</span>\
                 <span class="s2">&quot;Furthermore, the Brain Connectivity Toolbox (BCT) for MATLAB must be installed &quot;</span><span class="o">+</span>\
                 <span class="s2">&quot;in the octave search path. &quot;</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="c1"># Check the two mandatory inputs</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span><span class="s1">&#39;nw&#39;</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

    <span class="c1"># See if the string `method` is one of the supported randomization algorithms</span>
    <span class="n">supported</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span><span class="s2">&quot;randmio_und_connected&quot;</span><span class="p">,</span><span class="s2">&quot;randmio_und&quot;</span><span class="p">,</span><span class="s2">&quot;null_model_und_sign&quot;</span><span class="p">,</span>\
                 <span class="s2">&quot;randmio_dir_connected&quot;</span><span class="p">,</span><span class="s2">&quot;randmio_dir&quot;</span><span class="p">,</span><span class="s2">&quot;null_model_dir_sign&quot;</span><span class="p">,</span>\
                 <span class="s2">&quot;randmio_und_signed&quot;</span><span class="p">,</span><span class="s2">&quot;randmio_dir_signed&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">supported</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sp_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">supported</span><span class="p">)</span>
        <span class="n">sp_str</span> <span class="o">=</span> <span class="n">sp_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">sp_str</span> <span class="o">=</span> <span class="n">sp_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Network cannot be randomized with `&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="o">+</span>\
              <span class="s1">&#39;`. Available options are: &#39;</span><span class="o">+</span><span class="n">sp_str</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># See if `rwr` makes sense</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">rwr</span><span class="p">,</span><span class="s1">&#39;rwr&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

    <span class="c1"># Now `rwr_max`</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">rwr</span><span class="p">,</span><span class="s1">&#39;rwr_max&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="n">rwr</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    
    <span class="c1"># Try to import progressbar module</span>
    <span class="k">try</span><span class="p">:</span> 
        <span class="kn">import</span> <span class="nn">progressbar</span> <span class="k">as</span> <span class="nn">pb</span>
        <span class="n">showbar</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="nb">print</span> <span class="s2">&quot;WARNING: progressbar module not found - consider installing it using `pip install progressbar`&quot;</span>
        <span class="n">showbar</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Allocate space for random networks</span>
    <span class="n">rnws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">))</span>
    <span class="n">rnw</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
    <span class="n">rw</span>   <span class="o">=</span> <span class="n">rwr</span>

    <span class="c1"># Unless the user explicitly specified a randomization strategy, choose one based on the</span>
    <span class="c1"># input network&#39;s properties</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
        <span class="n">min_nw</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">sgds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;unsigned&quot;</span><span class="p">,</span><span class="s2">&quot;signed&quot;</span><span class="p">][</span><span class="n">min_nw</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">issym</span><span class="p">(</span><span class="n">nw</span><span class="p">):</span>                                   <span class="c1"># undirected graphs</span>
            <span class="n">drct</span> <span class="o">=</span> <span class="s2">&quot;undirected&quot;</span>
            <span class="n">dns</span> <span class="o">=</span> <span class="n">density_und</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dns</span> <span class="o">&gt;</span> <span class="mf">0.75</span><span class="p">:</span>
                <span class="n">randomizer</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">null_model_und_sign</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">min_nw</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">randomizer</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">randmio_und_signed</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">randomizer</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">randmio_und</span>
        <span class="k">else</span><span class="p">:</span>                                           <span class="c1"># directed graphs</span>
            <span class="n">drct</span> <span class="o">=</span> <span class="s2">&quot;directed&quot;</span>
            <span class="n">dns</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">density_dir</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dns</span> <span class="o">&gt;</span> <span class="mf">0.75</span><span class="p">:</span>           
                <span class="n">randomizer</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">null_model_dir_sign</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">min_nw</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">randomizer</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">randmio_dir_signed</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">randomizer</span> <span class="o">=</span> <span class="n">octave</span><span class="o">.</span><span class="n">randmio_dir</span>
        <span class="nb">print</span> <span class="s2">&quot;Input network is &quot;</span><span class="o">+</span><span class="n">drct</span><span class="o">+</span><span class="s2">&quot; and &quot;</span><span class="o">+</span><span class="n">sgds</span><span class="o">+</span><span class="s2">&quot; with an edge-density of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1e2</span><span class="o">*</span><span class="n">dns</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;%. &quot;</span><span class="o">+</span>\
            <span class="s2">&quot;Using `&quot;</span><span class="o">+</span><span class="n">randomizer</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s2">&quot;` for randomization...&quot;</span>

    <span class="c1"># Depending on whether the chosen randomizer returns effective re-wiring numbers, a slightly different</span>
    <span class="c1"># while loop structure is necessary</span>
    <span class="n">use_nm</span> <span class="o">=</span> <span class="n">randomizer</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;null_model&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="c1"># If available, initialize progressbar</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span> 
        <span class="n">widgets</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Calculating Random Networks: &#39;</span><span class="p">,</span><span class="n">pb</span><span class="o">.</span><span class="n">Percentage</span><span class="p">(),</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">pb</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">),</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">pb</span><span class="o">.</span><span class="n">ETA</span><span class="p">()]</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">ProgressBar</span><span class="p">(</span><span class="n">widgets</span><span class="o">=</span><span class="n">widgets</span><span class="p">,</span><span class="n">maxval</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>

    <span class="c1"># Populate tensor</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span> <span class="n">pbar</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">use_nm</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">rwr</span> <span class="o">=</span> <span class="n">rw</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">while</span> <span class="n">rwr</span> <span class="o">&lt;=</span> <span class="n">rwr_max</span> <span class="ow">and</span> <span class="n">ok</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">rnw</span> <span class="o">=</span> <span class="n">randomizer</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span><span class="n">rwr</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">rnw</span><span class="p">,</span><span class="n">nw</span><span class="p">)</span>
                <span class="n">rwr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;WARNING: network &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; has not been randomized!&quot;</span>
            <span class="n">rnws</span><span class="p">[:,:,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">rnw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span> <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">rwr</span> <span class="o">=</span> <span class="n">rw</span>
            <span class="n">eff</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">rwr</span> <span class="o">&lt;=</span> <span class="n">rwr_max</span> <span class="ow">and</span> <span class="n">eff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rnw</span><span class="p">,</span><span class="n">eff</span> <span class="o">=</span> <span class="n">randomizer</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span><span class="n">rwr</span><span class="p">)</span>
                <span class="n">rwr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">eff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;WARNING: network &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; has not been randomized!&quot;</span>
            <span class="n">rnws</span><span class="p">[:,:,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">rnw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span> <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">showbar</span><span class="p">):</span> <span class="n">pbar</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">rnws</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="hdfburp"><a class="viewcode-back" href="../_stubs/nws_tools.hdfburp.html#nws_tools.hdfburp">[docs]</a><span class="k">def</span> <span class="nf">hdfburp</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pump out everything stored in a HDF5 container</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : h5py file object</span>
<span class="sd">        File object created using `h5py.File()`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing : None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function takes an `h5py`-file object and creates variables in the caller&#39;s</span>
<span class="sd">    local name-space corresponding to the respective dataset-names in the file. </span>
<span class="sd">    The naming format of the generated variables is `groupname_datasetname`,</span>
<span class="sd">    where the `groupname` is empty for datasets in the `root` directory of the file. </span>
<span class="sd">    Thus, if a HDF5 file contains the datasets</span>
<span class="sd">        `/a`</span>

<span class="sd">        `/b`</span>

<span class="sd">        `/group1/c`</span>

<span class="sd">        `/group1/d`</span>

<span class="sd">        `/group2/a`</span>

<span class="sd">        `/group2/b`</span>

<span class="sd">    then this routine creates the variables</span>

<span class="sd">        `a`</span>

<span class="sd">        `b`</span>

<span class="sd">        `group1_c`</span>

<span class="sd">        `group1_d`</span>

<span class="sd">        `group2_a`</span>

<span class="sd">        `group2_b`</span>

<span class="sd">    in the caller&#39;s workspace. </span>

<span class="sd">    The black magic part of the code was taken from Pykler&#39;s answer to </span>
<span class="sd">    `this stackoverflow question &lt;http://stackoverflow.com/questions/2515450/injecting-variables-into-the-callers-scope&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    WARNING: EXISTING VARIABLES IN THE CALLER&#39;S WORKSPACE ARE MERCILESSLY OVERWRITTEN!!!</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    h5py : a Pythonic interface to the HDF5 binary data format.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;HDF5 file&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input must be a valid HDF5 file identifier!&#39;</span><span class="p">)</span>

    <span class="c1"># Initialize necessary variables</span>
    <span class="n">mymap</span>      <span class="o">=</span> <span class="p">{}</span>
    <span class="n">grplist</span>    <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span>
    <span class="n">nameprefix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># As long as we find groups in the file, keep iterating</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">grplist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Get current group (in the first iteration, that&#39;s just the file itself)</span>
        <span class="n">mygrp</span> <span class="o">=</span> <span class="n">grplist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If it actually is a group, extract the group name to prefix to variable names</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mygrp</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nameprefix</span> <span class="o">=</span> <span class="n">mygrp</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span>

        <span class="c1"># Iterate through group items</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">mygrp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># If the current item is a group, add it to the list and keep going</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;HDF5 group&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">grplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

            <span class="c1"># If we found a variable, name it following the scheme: `groupname_varname`</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="n">nameprefix</span> <span class="o">+</span> <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mymap</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Done with the current group, pop it from list</span>
        <span class="n">grplist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">grplist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">mygrp</span><span class="p">))</span>

    <span class="c1"># Update caller&#39;s variable scope (this is black magic...)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">locals_</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">f_locals</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">stack</span>
    <span class="n">locals_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mymap</span><span class="p">)</span></div>

<span class="c1">##########################################################################################</span>
<span class="k">def</span> <span class="nf">normalize_time_series</span><span class="p">(</span><span class="n">time_series_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalizes a (real/complex) time series to zero mean and unit variance. </span>
<span class="sd">    WARNING: Modifies the given array in place!</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time_series_array : NumPy 2d array</span>
<span class="sd">        Array of data values per time point. Format is: `timepoints`-by-`N`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing : None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function does *not* do any error checking and assumes you know what you are doing</span>
<span class="sd">    This function is part of the `pyunicorn` package, developed by </span>
<span class="sd">    Jonathan F. Donges and Jobst Heitzig. The package is currently available </span>
<span class="sd">    `here &lt;http://www.pik-potsdam.de/~donges/pyunicorn/index.html&gt;`_</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    pyunicorn : A UNIfied COmplex Network and Recurrence aNalysis toolbox</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ts = np.arange(16).reshape(4,4).astype(&quot;float&quot;)</span>
<span class="sd">    &gt;&gt;&gt; normalize_time_series(ts)</span>
<span class="sd">    &gt;&gt;&gt; ts.mean(axis=0)</span>
<span class="sd">    array([ 0.,  0.,  0.,  0.])</span>
<span class="sd">    &gt;&gt;&gt; ts.std(axis=0)</span>
<span class="sd">    array([ 1.,  1.,  1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; ts[:,0]</span>
<span class="sd">    array([-1.34164079, -0.4472136 ,  0.4472136 ,  1.34164079])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#  Remove mean value from time series at each node (grid point)</span>
    <span class="n">time_series_array</span> <span class="o">-=</span> <span class="n">time_series_array</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1">#  Normalize the variance of anomalies to one</span>
    <span class="n">time_series_array</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">time_series_array</span> <span class="o">*</span> 
                                <span class="n">time_series_array</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        
    <span class="c1">#  Correct for grid points with zero variance in their time series</span>
    <span class="n">time_series_array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">time_series_array</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    
<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="mutual_info"><a class="viewcode-back" href="../_stubs/nws_tools.mutual_info.html#nws_tools.mutual_info">[docs]</a><span class="k">def</span> <span class="nf">mutual_info</span><span class="p">(</span><span class="n">tsdata</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm_ts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a (normalized) mutual information matrix at zero lag</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tsdata : NumPy 2d array</span>
<span class="sd">        Array of data values per time point. Format is: `timepoints`-by-`N`. Note that </span>
<span class="sd">        both `timepoints` and `N` have to be `&gt;= 2` (i.e., the code needs at least two time-series </span>
<span class="sd">        of minimum length 2)</span>
<span class="sd">    n_bins : int </span>
<span class="sd">        Number of bins for estimating probability distributions</span>
<span class="sd">    normalized : bool</span>
<span class="sd">        If `True`, the normalized mutual information (NMI) is computed</span>
<span class="sd">        otherwise the raw mutual information (not bounded from above) is calculated</span>
<span class="sd">        (see Notes for details). </span>
<span class="sd">    fast : bool</span>
<span class="sd">        Use C++ code to calculate (N)MI. If `False`, then </span>
<span class="sd">        a (significantly) slower Python implementation is employed </span>
<span class="sd">        (provided in case the compilation of the C++ code snippets </span>
<span class="sd">        fails on a system)</span>
<span class="sd">    norm_ts : bool</span>
<span class="sd">        If `True` the input time-series is normalized to zero mean and unit variance (default). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mi : NumPy 2d array</span>
<span class="sd">        `N`-by-`N` matrix of pairwise (N)MI coefficients of the input time-series</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For two random variables :math:`X` and :math:`Y` the raw mutual information </span>
<span class="sd">    is given by </span>

<span class="sd">    .. math:: MI(X,Y) = H(X) + H(Y) - H(X,Y),</span>

<span class="sd">    where :math:`H(X)` and :math:`H(Y)` denote the Shannon entropies of </span>
<span class="sd">    :math:`X` and :math:`Y`, respectively, and :math:`H(X,Y)` is their joint </span>
<span class="sd">    entropy. By default, this function normalizes the raw mutual information </span>
<span class="sd">    :math:`MI(X,Y)` by the geometric mean of :math:`H(X)` and :math:`H(Y)`</span>

<span class="sd">    .. math:: NMI(X,Y) = {MI(X,Y)\over\sqrt{H(X)H(Y)}}.</span>

<span class="sd">    The heavy lifting in this function is mainly done by code parts taken from </span>
<span class="sd">    the `pyunicorn` package, developed by Jonathan F. Donges  </span>
<span class="sd">    and Jobst Heitzig [1]_. It is currently available </span>
<span class="sd">    `here &lt;http://www.pik-potsdam.de/~donges/pyunicorn/index.html&gt;`_</span>
<span class="sd">    The code has been modified so that weave and pure Python codes are now </span>
<span class="sd">    part of the same function. Further, the original code computes the raw mutual information </span>
<span class="sd">    only. Both Python and C++ parts have been extended to compute a normalized </span>
<span class="sd">    mutual information too. </span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    pyunicorn.pyclimatenetwork.mutual_info_climate_network : classes in this module</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; tsdata = np.random.rand(150,2) # 2 time-series of length 150</span>
<span class="sd">    &gt;&gt;&gt; NMI = mutual_info(tsdata)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Copyright (C) 2008-2015, Jonathan F. Donges (Potsdam-Institute for Climate</span>
<span class="sd">           Impact Research), pyunicorn authors. All rights reserved.</span>
<span class="sd">           Redistribution and use in source and binary forms, with or without</span>
<span class="sd">           modification, are permitted provided that the following conditions are met:</span>
<span class="sd">               * Redistributions of source code must retain the above copyright notice, this</span>
<span class="sd">                 list of conditions and the following disclaimer.</span>
<span class="sd">               * Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="sd">                 this list of conditions and the following disclaimer in the documentation</span>
<span class="sd">                 and/or other materials provided with the distribution.</span>
<span class="sd">               * Neither the name of pyunicorn authors and the Potsdam-Institute for</span>
<span class="sd">                 Climate Impact Research nor the names of its contributors may be used to</span>
<span class="sd">                 endorse or promote products derived from this software without specific</span>
<span class="sd">                 prior written permission.</span>
<span class="sd">           THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="sd">           ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="sd">           WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="sd">           DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span>
<span class="sd">           FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="sd">           DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="sd">           SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="sd">           CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="sd">           OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="sd">           OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks (`tsdata` is probably not square, that&#39;s why we don&#39;t use `arrcheck` here)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">shtsdata</span> <span class="o">=</span> <span class="n">tsdata</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input must be a timepoint-by-index NumPy 2d array, not &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">tsdata</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shtsdata</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input must be a timepoint-by-index NumPy 2d array&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">shtsdata</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least two time-series/two time-points are required to compute (N)MI!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">tsdata</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">tsdata</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input must be real-valued!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">tsdata</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input must be a real valued NumPy 2d array without Infs or NaNs!&#39;</span><span class="p">)</span>

    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span><span class="s1">&#39;n_bins&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">bvar</span> <span class="ow">in</span> <span class="p">[</span><span class="n">normalized</span><span class="p">,</span><span class="n">fast</span><span class="p">,</span><span class="n">norm_ts</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bvar</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The flags `normalized`, `fast` and `norm_ts` must be Boolean!&#39;</span><span class="p">)</span>
    
    <span class="c1">#  Get faster reference to length of time series = number of samples</span>
    <span class="c1">#  per grid point.</span>
    <span class="p">(</span><span class="n">n_samples</span><span class="p">,</span><span class="n">N</span><span class="p">)</span> <span class="o">=</span> <span class="n">tsdata</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1">#  Normalize `tsdata` time series to zero mean and unit variance</span>
    <span class="k">if</span> <span class="n">norm_ts</span><span class="p">:</span>
        <span class="n">normalize_time_series</span><span class="p">(</span><span class="n">tsdata</span><span class="p">)</span>

    <span class="c1">#  Initialize mutual information array</span>
    <span class="n">mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="c1"># Execute C++ code</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fast</span><span class="p">):</span>

        <span class="c1"># Create local transposed copy of `tsdata`</span>
        <span class="n">tsdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fastCopyAndTranspose</span><span class="p">(</span><span class="n">tsdata</span><span class="p">)</span>
                
        <span class="c1"># Get common range for all histograms</span>
        <span class="n">range_min</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tsdata</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">range_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tsdata</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        
        <span class="c1"># Re-scale all time series to the interval [0,1], </span>
        <span class="c1"># using the maximum range of the whole dataset.</span>
        <span class="n">denom</span>   <span class="o">=</span> <span class="n">range_max</span> <span class="o">-</span> <span class="n">range_min</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">range_max</span> <span class="o">!=</span> <span class="n">range_min</span><span class="p">)</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span>
        
        <span class="c1"># Create array to hold symbolic trajectories</span>
        <span class="n">symbolic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">tsdata</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        
        <span class="c1"># Initialize array to hold 1d-histograms of individual time series</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">n_bins</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        
        <span class="c1"># Initialize array to hold 2d-histogram for one pair of time series</span>
        <span class="n">hist2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_bins</span><span class="p">,</span><span class="n">n_bins</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
                
        <span class="c1"># C++ code to compute NMI</span>
        <span class="n">code_nmi</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        int i, j, k, l, m;</span>
<span class="s2">        int symbol, symbol_i, symbol_j; </span>
<span class="s2">        double norm, rescaled, hpl, hpm, plm, Hl, Hm;</span>

<span class="s2">        //  Calculate histogram norm</span>
<span class="s2">        norm = 1.0 / n_samples;</span>

<span class="s2">        for (i = 0; i &lt; N; i++) {</span>
<span class="s2">            for (k = 0; k &lt; n_samples; k++) {</span>

<span class="s2">                //  Calculate symbolic trajectories for each time series, </span>
<span class="s2">                //  where the symbols are bins.</span>
<span class="s2">                rescaled = scaling * (tsdata(i,k) - range_min);</span>

<span class="s2">                if (rescaled &lt; 1.0) {</span>
<span class="s2">                    symbolic(i,k) = rescaled * n_bins;</span>
<span class="s2">                }</span>
<span class="s2">                else {</span>
<span class="s2">                    symbolic(i,k) = n_bins - 1;</span>
<span class="s2">                }</span>

<span class="s2">                //  Calculate 1d-histograms for single time series</span>
<span class="s2">                symbol = symbolic(i,k);</span>
<span class="s2">                hist(i,symbol) += 1;</span>
<span class="s2">            }</span>
<span class="s2">        }</span>

<span class="s2">        for (i = 0; i &lt; N; i++) {</span>
<span class="s2">            for (j = 0; j &lt;= i; j++) {</span>

<span class="s2">                //  The case `i = j` is not of interest here!</span>
<span class="s2">                if (i != j) {</span>
<span class="s2">                    //  Calculate 2d-histogram for one pair of time series </span>
<span class="s2">                    //  (i,j).</span>
<span class="s2">                    for (k = 0; k &lt; n_samples; k++) {</span>
<span class="s2">                        symbol_i = symbolic(i,k);</span>
<span class="s2">                        symbol_j = symbolic(j,k);</span>
<span class="s2">                        hist2d(symbol_i,symbol_j) += 1;</span>
<span class="s2">                    }</span>

<span class="s2">                    //  Calculate mutual information for one pair of time </span>
<span class="s2">                    //  series (i,j).</span>
<span class="s2">                    Hl = 0;</span>
<span class="s2">                    for (l = 0; l &lt; n_bins; l++) {</span>
<span class="s2">                        hpl = hist(i,l) * norm;</span>
<span class="s2">                        if (hpl &gt; 0.0) {</span>
<span class="s2">                            Hl += hpl * log(hpl);</span>
<span class="s2">                            Hm = 0;</span>
<span class="s2">                            for (m = 0; m &lt; n_bins; m++) {</span>
<span class="s2">                                hpm = hist(j,m) * norm;</span>
<span class="s2">                                if (hpm &gt; 0.0) {</span>
<span class="s2">                                    Hm += hpm * log(hpm);</span>
<span class="s2">                                    plm = hist2d(l,m) * norm;</span>
<span class="s2">                                    if (plm &gt; 0.0) {</span>
<span class="s2">                                        mi(i,j) += plm * log(plm/hpm/hpl);</span>
<span class="s2">                                    }</span>
<span class="s2">                                }</span>
<span class="s2">                            }</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>

<span class="s2">                    // Divide by the marginal entropies to normalize MI</span>
<span class="s2">                    mi(i,j) = mi(i,j) / sqrt(Hm * Hl);</span>

<span class="s2">                    //  Symmetrize MI</span>
<span class="s2">                    mi(j,i) = mi(i,j);</span>

<span class="s2">                    //  Reset `hist2d` to zero in all bins</span>
<span class="s2">                    for (l = 0; l &lt; n_bins; l++) {</span>
<span class="s2">                        for (m = 0; m &lt; n_bins; m++) {</span>
<span class="s2">                            hist2d(l,m) = 0;</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }</span>
<span class="s2">                // Put ones on the diagonal</span>
<span class="s2">                else {</span>
<span class="s2">                    mi(i,j) = 1.0;</span>
<span class="s2">                }</span>

<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">        &quot;&quot;&quot;</span>

        <span class="c1"># C++ code to compute MI</span>
        <span class="n">code_mi</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        int i, j, k, l, m;</span>
<span class="s2">        int symbol, symbol_i, symbol_j; </span>
<span class="s2">        double norm, rescaled, hpl, hpm, plm;</span>

<span class="s2">        //  Calculate histogram norm</span>
<span class="s2">        norm = 1.0 / n_samples;</span>

<span class="s2">        for (i = 0; i &lt; N; i++) {</span>
<span class="s2">            for (k = 0; k &lt; n_samples; k++) {</span>

<span class="s2">                //  Calculate symbolic trajectories for each time series, </span>
<span class="s2">                //  where the symbols are bins.</span>
<span class="s2">                rescaled = scaling * (tsdata(i,k) - range_min);</span>

<span class="s2">                if (rescaled &lt; 1.0) {</span>
<span class="s2">                    symbolic(i,k) = rescaled * n_bins;</span>
<span class="s2">                }</span>
<span class="s2">                else {</span>
<span class="s2">                    symbolic(i,k) = n_bins - 1;</span>
<span class="s2">                }</span>

<span class="s2">                //  Calculate 1d-histograms for single time series</span>
<span class="s2">                symbol = symbolic(i,k);</span>
<span class="s2">                hist(i,symbol) += 1;</span>
<span class="s2">            }</span>
<span class="s2">        }</span>

<span class="s2">        for (i = 0; i &lt; N; i++) {</span>
<span class="s2">            for (j = 0; j &lt;= i; j++) {</span>

<span class="s2">                //  The case i = j is not of interest here!</span>
<span class="s2">                if (i != j) {</span>
<span class="s2">                    //  Calculate 2d-histogram for one pair of time series </span>
<span class="s2">                    //  `(i,j)`.</span>
<span class="s2">                    for (k = 0; k &lt; n_samples; k++) {</span>
<span class="s2">                        symbol_i = symbolic(i,k);</span>
<span class="s2">                        symbol_j = symbolic(j,k);</span>
<span class="s2">                        hist2d(symbol_i,symbol_j) += 1;</span>
<span class="s2">                    }</span>

<span class="s2">                    //  Calculate mutual information for one pair of time </span>
<span class="s2">                    //  series `(i,j)`.</span>
<span class="s2">                    // Hl = 0;</span>
<span class="s2">                    for (l = 0; l &lt; n_bins; l++) {</span>
<span class="s2">                        hpl = hist(i,l) * norm;</span>
<span class="s2">                        if (hpl &gt; 0.0) {</span>
<span class="s2">                            // `Hl += hpl * log(hpl);`</span>
<span class="s2">                            // `Hm = 0;`</span>
<span class="s2">                            for (m = 0; m &lt; n_bins; m++) {</span>
<span class="s2">                                hpm = hist(j,m) * norm;</span>
<span class="s2">                                if (hpm &gt; 0.0) {</span>
<span class="s2">                                    // `Hm += hpm * log(hpm);`</span>
<span class="s2">                                    plm = hist2d(l,m) * norm;</span>
<span class="s2">                                    if (plm &gt; 0.0) {</span>
<span class="s2">                                        mi(i,j) += plm * log(plm/hpm/hpl);</span>
<span class="s2">                                    }</span>
<span class="s2">                                }</span>
<span class="s2">                            }</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>

<span class="s2">                    //  Symmetrize MI</span>
<span class="s2">                    mi(j,i) = mi(i,j);</span>

<span class="s2">                    //  Reset `hist2d` to zero in all bins</span>
<span class="s2">                    for (l = 0; l &lt; n_bins; l++) {</span>
<span class="s2">                        for (m = 0; m &lt; n_bins; m++) {</span>
<span class="s2">                            hist2d(l,m) = 0;</span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">                }</span>
<span class="s2">                // Put ones on the diagonal</span>
<span class="s2">                else {</span>
<span class="s2">                    mi(i,j) = 1.0;</span>
<span class="s2">                }</span>

<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize necessary variables to pass on to C++ code snippets above</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tsdata&#39;</span><span class="p">,</span> <span class="s1">&#39;n_samples&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;n_bins&#39;</span><span class="p">,</span> <span class="s1">&#39;scaling&#39;</span><span class="p">,</span> <span class="s1">&#39;range_min&#39;</span><span class="p">,</span> 
                <span class="s1">&#39;symbolic&#39;</span><span class="p">,</span> <span class="s1">&#39;hist&#39;</span><span class="p">,</span> <span class="s1">&#39;hist2d&#39;</span><span class="p">,</span> <span class="s1">&#39;mi&#39;</span><span class="p">]</span>

        <span class="c1"># Compute normalized or non-normalized mutual information</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">normalized</span><span class="p">):</span>
            <span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="n">code_nmi</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">,</span> 
                         <span class="n">compiler</span><span class="o">=</span><span class="s1">&#39;gcc&#39;</span><span class="p">,</span> <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-O3&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weave</span><span class="o">.</span><span class="n">inline</span><span class="p">(</span><span class="n">code_mi</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">type_converters</span><span class="o">=</span><span class="n">weave</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">blitz</span><span class="p">,</span> 
                         <span class="n">compiler</span><span class="o">=</span><span class="s1">&#39;gcc&#39;</span><span class="p">,</span> <span class="n">extra_compile_args</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-O3&#39;</span><span class="p">])</span>
        
    <span class="c1"># Python version of (N)MI computation (slower)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1">#  Define references to NumPy functions for faster function calls</span>
        <span class="n">histogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span>
        <span class="n">histogram2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span> 

        <span class="c1">#  Get common range for all histograms</span>
        <span class="n">range_min</span> <span class="o">=</span> <span class="n">tsdata</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">range_max</span> <span class="o">=</span> <span class="n">tsdata</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1">#  Calculate the histograms for each time series</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">histogram</span><span class="p">(</span><span class="n">tsdata</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span> 
                            <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="n">range_min</span><span class="p">,</span><span class="n">range_max</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>

        <span class="c1">#  Normalize by total number of samples = length of each time series</span>
        <span class="n">p</span> <span class="o">/=</span> <span class="n">n_samples</span>

        <span class="c1">#  Make sure that bins with zero estimated probability are not counted </span>
        <span class="c1">#  in the entropy measures.</span>
        <span class="n">p</span><span class="p">[</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1">#  Compute the information entropies of each time series</span>
        <span class="n">H</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1">#  Calculate only the lower half of the MI matrix, since MI is </span>
        <span class="c1">#  symmetric with respect to `X` and `Y`.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>

                <span class="c1">#  Calculate the joint probability distribution</span>
                <span class="n">pxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">tsdata</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="n">tsdata</span><span class="p">[:,</span><span class="n">j</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span> 
                            <span class="nb">range</span><span class="o">=</span><span class="p">((</span><span class="n">range_min</span><span class="p">,</span> <span class="n">range_max</span><span class="p">),</span> 
                            <span class="p">(</span><span class="n">range_min</span><span class="p">,</span> <span class="n">range_max</span><span class="p">)))[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>

                <span class="c1">#  Normalize joint distribution</span>
                <span class="n">pxy</span> <span class="o">/=</span> <span class="n">n_samples</span>

                <span class="c1">#  Compute the joint information entropy</span>
                <span class="n">pxy</span><span class="p">[</span><span class="n">pxy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">HXY</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">pxy</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">pxy</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="c1"># Normalize by entropies (or not)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">normalized</span><span class="p">):</span>
                    <span class="n">mi</span><span class="o">.</span><span class="n">itemset</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">H</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">HXY</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">j</span><span class="p">))))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mi</span><span class="o">.</span><span class="n">itemset</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">H</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">H</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">HXY</span><span class="p">)</span>

                <span class="c1"># Symmetrize MI</span>
                <span class="n">mi</span><span class="o">.</span><span class="n">itemset</span><span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">),</span> <span class="n">mi</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)))</span>

        <span class="c1"># Put ones on the diagonal</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Return (N)MI matrix</span>
    <span class="k">return</span> <span class="n">mi</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="issym"><a class="viewcode-back" href="../_stubs/nws_tools.issym.html#nws_tools.issym">[docs]</a><span class="k">def</span> <span class="nf">issym</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check for symmetry of a 2d NumPy array</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : NumPy 2darray</span>
<span class="sd">        A presumably symmetric matrix</span>
<span class="sd">    tol : float</span>
<span class="sd">        Tolerance :math:`\\tau` for checking if :math:`A` is sufficiently close to :math:`A^\\top`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_sym : bool</span>
<span class="sd">        True if :math:`A` satisfies :math:`|A - A^\\top| \\leq \\tau |A|`,</span>
<span class="sd">        where :math:`|\\cdot|` denotes the Frobenius norm. Thus, if this inequality </span>
<span class="sd">        holds, :math:`A` is approximately symmetric. </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For further details regarding the Frobenius norm approach used, please refer to the </span>
<span class="sd">    discussion in `this &lt;http://www.mathworks.com/matlabcentral/newsreader/view_thread/252727&gt;`_ </span>
<span class="sd">    thread at MATLAB central</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    isclose : An absolute-value based comparison readily provided by NumPy. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if Frobenius norm of `A - A.T` is sufficiently small (respecting round-off errors)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">is_sym</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="o">-</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="nb">ord</span><span class="o">=</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="nb">ord</span><span class="o">=</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input argument has to be a square matrix/array and a scalar tol (optional)!&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">is_sym</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="printdata"><a class="viewcode-back" href="../_stubs/nws_tools.printdata.html#nws_tools.printdata">[docs]</a><span class="k">def</span> <span class="nf">printdata</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">leadrow</span><span class="p">,</span><span class="n">leadcol</span><span class="p">,</span><span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pretty-print/-save array-like data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : NumPy 2darray</span>
<span class="sd">        An `M`-by-`N` array of data</span>
<span class="sd">    leadrow : Python list or NumPy 1darray</span>
<span class="sd">        List/array of length `N` or `N+1` providing labels to be printed in the first row of the table</span>
<span class="sd">        (strings/numerals or both). See Examples for details</span>
<span class="sd">    leadcol : Python list or NumPy 1darray</span>
<span class="sd">        List/array of length `M` providing labels to be printed in the first column of the table</span>
<span class="sd">        (strings/numerals or both)</span>
<span class="sd">    fname : str</span>
<span class="sd">        Name of a csv-file (with or without extension `.csv`) used to save the table </span>
<span class="sd">        (WARNING: existing files will be overwritten!). Can also be a path + filename </span>
<span class="sd">        (e.g., `fname=&#39;path/to/file.csv&#39;`). By default output is not saved. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing : None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Uses the `texttable` module to print results</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; data = np.random.rand(2,3)</span>
<span class="sd">    &gt;&gt;&gt; row1 = [&quot;a&quot;,&quot;b&quot;,3]</span>
<span class="sd">    &gt;&gt;&gt; col1 = np.arange(2)</span>
<span class="sd">    &gt;&gt;&gt; printdata(data,row1,col1)</span>
<span class="sd">    +--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">    |                    |         a          |         b          |         3          |</span>
<span class="sd">    +====================+====================+====================+====================+</span>
<span class="sd">    | 0                  | 0.994018537964     | 0.707532139166     | 0.767497407803     |</span>
<span class="sd">    +--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">    | 1                  | 0.914193045048     | 0.758181936461     | 0.216752553325     |</span>
<span class="sd">    +--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">    &gt;&gt;&gt; row1 = [&quot;labels&quot;] + row1</span>
<span class="sd">    &gt;&gt;&gt; printdata(data,row1,col1,fname=&#39;dummy&#39;)</span>
<span class="sd">    +--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">    |       labels       |         a          |         b          |         3          |</span>
<span class="sd">    +====================+====================+====================+====================+</span>
<span class="sd">    | 0                  | 0.994018537964     | 0.707532139166     | 0.767497407803     |</span>
<span class="sd">    +--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">    | 1                  | 0.914193045048     | 0.758181936461     | 0.216752553325     |</span>
<span class="sd">    +--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">    &gt;&gt;&gt; cat dummy.csv</span>
<span class="sd">    labels, a, b, 3</span>
<span class="sd">    0,0.994018537964,0.707532139166,0.767497407803</span>
<span class="sd">    1,0.914193045048,0.758181936461,0.216752553325</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    texttable : a module for creating simple ASCII tables (currently available at the </span>
<span class="sd">                `Python Package Index &lt;https://pypi.python.org/pypi/texttable/0.8.1&gt;`_)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Try to import Texttable object</span>
    <span class="k">try</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">texttable</span> <span class="k">import</span> <span class="n">Texttable</span>
    <span class="k">except</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Could not import texttable! Consider installing it using pip install texttable&quot;</span><span class="p">)</span>

    <span class="c1"># Check dimensions of input</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input must be a M-by-N NumPy array, not &#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input must be a M-by-N NumPy array!&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">lvar</span> <span class="ow">in</span> <span class="p">[</span><span class="n">leadcol</span><span class="p">,</span><span class="n">leadrow</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lvar</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The inputs `leadcol` and `leadrow` must by Python lists or Numpy 1d arrays!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lvar</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The inputs `leadcol` and `leadrow` must 1-d lists/arrays!&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leadcol</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leadrow</span><span class="p">)</span>

    <span class="c1"># If a filename was provided make sure it&#39;s a string and check if the path exists</span>
    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Optional output filename has to be a string!&#39;</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">fname</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">slash</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slash</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">fname</span><span class="p">[:</span><span class="n">fname</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid path for output file: &#39;</span><span class="o">+</span><span class="n">fname</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">::]</span> <span class="o">!=</span> <span class="s1">&#39;.csv&#39;</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.csv&#39;</span>
        <span class="n">save</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Get dimension of data and corresponding leading column/row</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="n">K</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">K</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">K</span>
        <span class="k">elif</span> <span class="n">K</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">K</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">N</span> <span class="o">=</span> <span class="n">K</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of elements in heading column/row and data don not match up!&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">ds</span>

    <span class="k">if</span> <span class="n">M</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of rows and no. of elements leading column do not match up!&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">leadrow</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">head</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">leadrow</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of columns and no. of elements in head row do not match up!&#39;</span><span class="p">)</span>

    <span class="c1"># Do something: create big data array including leading column</span>
    <span class="n">Data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">leadcol</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">)))</span>
    
    <span class="c1"># Initialize table object and fill it with stuff</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">Texttable</span><span class="p">()</span>
    <span class="n">table</span><span class="o">.</span><span class="n">set_cols_align</span><span class="p">([</span><span class="s2">&quot;l&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">table</span><span class="o">.</span><span class="n">set_cols_valign</span><span class="p">([</span><span class="s2">&quot;c&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">table</span><span class="o">.</span><span class="n">set_cols_dtype</span><span class="p">([</span><span class="s2">&quot;t&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">table</span><span class="o">.</span><span class="n">set_cols_width</span><span class="p">([</span><span class="mi">18</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">table</span><span class="o">.</span><span class="n">add_rows</span><span class="p">([</span><span class="n">head</span><span class="p">],</span><span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">add_rows</span><span class="p">(</span><span class="n">Data</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1"># Pump out table</span>
    <span class="nb">print</span> <span class="n">table</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="c1"># If wanted, save stuff in a csv file</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">head</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">Data</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span><span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="n">head</span><span class="p">,</span><span class="n">comments</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span></div>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="img2vid"><a class="viewcode-back" href="../_stubs/nws_tools.img2vid.html#nws_tools.img2vid">[docs]</a><span class="k">def</span> <span class="nf">img2vid</span><span class="p">(</span><span class="n">imgpth</span><span class="p">,</span><span class="n">imgfmt</span><span class="p">,</span><span class="n">outfile</span><span class="p">,</span><span class="n">fps</span><span class="p">,</span><span class="n">filesize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;mp4&#39;</span><span class="p">,</span><span class="n">preset</span><span class="o">=</span><span class="s1">&#39;veryslow&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a sequence of image files to a video using ffmpeg</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imgpth : str</span>
<span class="sd">        Path to image files</span>
<span class="sd">    imgfmt : str</span>
<span class="sd">        Format specifier for images. All files in the image stack have to follow the same naming </span>
<span class="sd">        convention, e.g., given the sequence `im_01.png`, `im_02.png`, ...,`im_99.png` the correct</span>
<span class="sd">        format specifier `imgfmt` is &#39;im_%02d.png&#39;</span>
<span class="sd">    outfile : str</span>
<span class="sd">        Filename (including path if not in current directory) for output video. If an extension </span>
<span class="sd">        is provided, e.g., &#39;animation.mp4&#39; it is passed on to the x264 video encoder in </span>
<span class="sd">        ffmpeg to set the video format of the output. Use `ffmpeg -formats` in a shell </span>
<span class="sd">        to get a list of supported formats (any format labeled &#39;Muxing supported&#39;). </span>
<span class="sd">    fps : int</span>
<span class="sd">        Framerate of the video (number of frames per second)</span>
<span class="sd">    filesize : float</span>
<span class="sd">        Target size of video file in MB (Megabytes). </span>
<span class="sd">        If provided, a encoding bitrate will be chosen such that the target size </span>
<span class="sd">        `filesize` is not exceeded. If `filesize = None` the default constant rate factor of ffmpeg</span>
<span class="sd">        is used (the longer the movie, the larger the generated file). </span>
<span class="sd">    ext : str</span>
<span class="sd">        Extension of the video-file. If `outfile` does not have a filetype extension, then </span>
<span class="sd">        the default value of `ext` is used and an mp4 video is generated. Note: if `outfile`</span>
<span class="sd">        has an extension, then any value of `ext` will be ignored. Use `ffmpeg -formats` in a shell </span>
<span class="sd">        to get a list of supported formats (any format labeled &#39;Muxing supported&#39;). </span>
<span class="sd">    preset : str</span>
<span class="sd">        Video quality options for ffmpeg&#39;s x264 encoder controlling the encoding speed to </span>
<span class="sd">        compression ratio. A slower preset results in better compression (higher quality </span>
<span class="sd">        per filesize) but longer encoding time. Available presets in ffmpeg  are </span>
<span class="sd">        &#39;ultrafast&#39;, &#39;superfast&#39;, &#39;veryfast&#39;, &#39;faster&#39;, &#39;fast&#39;, &#39;medium&#39;, &#39;slow&#39;, &#39;slower&#39;, &#39;veryslow&#39;, and &#39;placebo&#39;. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing : None</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose the 600 sequentially numbered tiff files `image_001.tiff`, `image_002.tiff`, ..., `image_600.tiff`</span>
<span class="sd">    located in the directory `/path/to/images/ ` have to be converted to Quicktime movie (mov file) of no more than 25MB size. </span>
<span class="sd">    We want the video to show 6 consecutive images per second (i.e., a framerate of 6 frames per second). </span>
<span class="sd">    This can be done using the following command</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; img2vid(&#39;/path/to/images&#39;,&#39;image_%03d.tiff&#39;,&#39;image_1_600&#39;,6,filesize=25,ext=&#39;mov&#39;,preset=&#39;veryslow&#39;)</span>

<span class="sd">    Alternatively,</span>

<span class="sd">    &gt;&gt;&gt; img2vid(&#39;/path/to/images&#39;,&#39;image_%03d.tiff&#39;,&#39;image_1_600_loq.mov&#39;,6,filesize=25,ext=&#39;mkv&#39;,preset=&#39;ultrafast&#39;)</span>

<span class="sd">    also generates an mov video of 25MB. The encoding will be faster but the image quality of `image_1_600_loq.mov` </span>
<span class="sd">    will be lower compared to `image_1_600.mov` generated by the first call. Note that the optional keyword argument </span>
<span class="sd">    `ext=&#39;mkv&#39;` is ignored since the provided output filename &#39;image_1_600_loq.mov&#39; already contains an extension. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># First and foremost, check if ffmpeg is available, otherwise everything else is irrelevant</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;which ffmpeg &gt; /dev/null&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Could not find ffmpeg. It seems like ffmpeg is either not installed or not in the search path. &quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Check if image directory exists and append trailing slash if necessary</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgpth</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Path to image directory has to be a string!&#39;</span><span class="p">)</span>
    <span class="n">imgpth</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">imgpth</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">imgpth</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">imgpth</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">imgpth</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">imgpth</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid path to image directory: &#39;</span><span class="o">+</span><span class="n">imgpth</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="n">slash</span> <span class="o">=</span> <span class="n">imgpth</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slash</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgpth</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> 
        <span class="n">imgpth</span> <span class="o">+=</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span>

    <span class="c1"># Check if `imgfmt` is a valid string format specifier </span>
    <span class="c1"># (don&#39;t use split below in case we have something like im.001.tiff)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgfmt</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Format specifier for images has to be a string!&#39;</span><span class="p">)</span>
    <span class="n">imgfmt</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">imgfmt</span><span class="p">)</span>
    <span class="n">dot</span>    <span class="o">=</span> <span class="n">imgfmt</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="n">fmt</span>    <span class="o">=</span> <span class="n">imgfmt</span><span class="p">[:</span><span class="n">dot</span><span class="p">]</span>
    <span class="n">imtype</span> <span class="o">=</span> <span class="n">imgfmt</span><span class="p">[</span><span class="n">dot</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">fmt</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid image format specifier: `&#39;</span><span class="o">+</span><span class="n">fmt</span><span class="o">+</span><span class="s1">&#39;`!&#39;</span><span class="p">)</span>
    
    <span class="c1"># Check if image directory actually contains any images of the given type</span>
    <span class="n">imgs</span>     <span class="o">=</span> <span class="n">natsort</span><span class="o">.</span><span class="n">natsorted</span><span class="p">(</span><span class="n">myglob</span><span class="p">(</span><span class="n">imgpth</span><span class="p">,</span><span class="s1">&#39;*.&#39;</span><span class="o">+</span><span class="n">imtype</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="n">num_imgs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_imgs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Directory &#39;</span><span class="o">+</span><span class="n">imgpth</span><span class="o">+</span><span class="s1">&#39; contains fewer than 2 `&#39;</span><span class="o">+</span><span class="n">imtype</span><span class="o">+</span><span class="s1">&#39;` files!&#39;</span><span class="p">)</span>

    <span class="c1"># Check validity of `outfile`</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outfile</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Output filename has to be a string!&#39;</span><span class="p">)</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outfile</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">outfile</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">slash</span> <span class="o">=</span> <span class="n">outfile</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slash</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outfile</span><span class="p">[:</span><span class="n">outfile</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid path to save movie: &#39;</span><span class="o">+</span><span class="n">outfile</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>

    <span class="c1"># Check format specifier for the movie: the if loop separates filename from extension</span>
    <span class="c1"># (use split here to prevent the user from creating abominations like `my.movie.mp4`)</span>
    <span class="n">dot</span> <span class="o">=</span> <span class="n">outfile</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">outfile</span><span class="o">+</span><span class="s1">&#39; is not a valid filename!&#39;</span><span class="p">)</span>          <span class="c1"># e.g., outfile = &#39;.name&#39;</span>
    <span class="k">if</span> <span class="n">dot</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>                                                 <span class="c1"># e.g., outfile = &#39;name.&#39;</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">[:</span><span class="n">dot</span><span class="p">]</span>
        <span class="n">dot</span>     <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">dot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>                                                                 <span class="c1"># e.g., outfile = &#39;name.mp4&#39;</span>
        <span class="n">out_split</span> <span class="o">=</span> <span class="n">outfile</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_split</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">outfile</span><span class="o">+</span><span class="s1">&#39; is not a valid filename!&#39;</span><span class="p">)</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">out_split</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># If outfile had an extension but there was an add&#39;l extension provided, warn the user</span>
        <span class="k">if</span> <span class="n">out_split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;mp4&#39;</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;WARNING: Using extension `&quot;</span><span class="o">+</span><span class="n">out_split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;` of output filename, not `&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;`!&quot;</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">out_split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>                                                                       <span class="c1"># e.g., outfile = &#39;name&#39;</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ext</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Filename extension for movie has to be a string!&#39;</span><span class="p">)</span>
        <span class="n">exl</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">ext</span><span class="o">+</span><span class="s1">&#39; is not a valid extension for a video file!&#39;</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">exl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Make sure `fps` is a positive integer</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">fps</span><span class="p">,</span><span class="s1">&#39;fps&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    
    <span class="c1"># Check if output filesize makes sense (if provided)</span>
    <span class="k">if</span> <span class="n">filesize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">filesize</span><span class="p">,</span><span class="s1">&#39;filesize&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

    <span class="c1"># Check if `preset` is valid (if provided)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preset</span><span class="p">,(</span><span class="nb">str</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Preset specifier for video encoding has to be a string!&#39;</span><span class="p">)</span>
    <span class="n">supported</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ultrafast&#39;</span><span class="p">,</span><span class="s1">&#39;superfast&#39;</span><span class="p">,</span><span class="s1">&#39;veryfast&#39;</span><span class="p">,</span><span class="s1">&#39;faster&#39;</span><span class="p">,</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span><span class="s1">&#39;medium&#39;</span><span class="p">,</span><span class="s1">&#39;slow&#39;</span><span class="p">,</span><span class="s1">&#39;slower&#39;</span><span class="p">,</span><span class="s1">&#39;veryslow&#39;</span><span class="p">,</span><span class="s1">&#39;placebo&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">supported</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">supported</span><span class="p">)</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Preset `&#39;</span><span class="o">+</span><span class="n">preset</span><span class="o">+</span><span class="s1">&#39;` not supported by ffmpeg. Supported options are: &#39;</span><span class="o">+</span><span class="n">opts</span><span class="p">)</span>

    <span class="c1"># Now let&#39;s start to actually do something and set the null device based on which platform we&#39;re running on</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">uname</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Windows&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nulldev</span> <span class="o">=</span> <span class="s1">&#39;NUL&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nulldev</span> <span class="o">=</span> <span class="s1">&#39;/dev/null&#39;</span>

    <span class="c1"># Encode movie respecting provided file-size limit</span>
    <span class="k">if</span> <span class="n">filesize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># Calculate movie length based on desired frame-rate and bit-rate such that given filesize is not exceeded (MB-&gt;kbit/s uses 8192)</span>
        <span class="n">movie_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_imgs</span><span class="o">/</span><span class="n">fps</span><span class="p">)</span>
        <span class="n">brate</span>     <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">filesize</span><span class="o">*</span><span class="mi">8192</span><span class="o">/</span><span class="n">movie_len</span><span class="p">))</span>
        
        <span class="c1"># Use two-pass encoding to ensure maximum image quality while keeping the filesize within specified bounds</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;ffmpeg -y -framerate &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; -f image2 -i &quot;</span><span class="o">+</span><span class="n">imgpth</span><span class="o">+</span><span class="n">imgfmt</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span>\
                  <span class="s2">&quot;-vf &#39;scale=trunc(iw/2)*2:trunc(ih/2)*2&#39; &quot;</span>
                  <span class="s2">&quot;-vcodec libx264 -preset &quot;</span><span class="o">+</span><span class="n">preset</span><span class="o">+</span><span class="s2">&quot; -pix_fmt yuv420p -b:v &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">brate</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;k -b:a 0k -pass 1 &quot;</span><span class="o">+</span>\
                  <span class="s2">&quot;-f &quot;</span><span class="o">+</span><span class="n">ext</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">nulldev</span><span class="o">+</span><span class="s2">&quot; &amp;&amp; &quot;</span><span class="o">+</span>\
                  <span class="s2">&quot;ffmpeg -framerate &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; -f image2 -i &quot;</span><span class="o">+</span><span class="n">imgpth</span><span class="o">+</span><span class="n">imgfmt</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span>\
                  <span class="s2">&quot;-vcodec libx264 -preset &quot;</span><span class="o">+</span><span class="n">preset</span><span class="o">+</span><span class="s2">&quot; -pix_fmt yuv420p -b:v &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">brate</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;k -b:a 0k -pass 2 &quot;</span><span class="o">+</span>\
                  <span class="s2">&quot;-vf &#39;scale=trunc(iw/2)*2:trunc(ih/2)*2&#39; &quot;</span><span class="o">+</span><span class="n">outfile</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">ext</span><span class="p">)</span>

    <span class="c1"># Encode movie with no regards given to final size</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Use a constant rate factor (incompatible with 2-pass encoding) to render the movie</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;ffmpeg -framerate &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; -f image2 -i &quot;</span><span class="o">+</span><span class="n">imgpth</span><span class="o">+</span><span class="n">imgfmt</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span>\
                  <span class="s2">&quot;-vcodec libx264 -preset &quot;</span><span class="o">+</span><span class="n">preset</span><span class="o">+</span><span class="s2">&quot; -pix_fmt yuv420p &quot;</span><span class="o">+</span>\
                  <span class="s2">&quot;-vf &#39;scale=trunc(iw/2)*2:trunc(ih/2)*2&#39; &quot;</span><span class="o">+</span><span class="n">outfile</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">ext</span><span class="p">)</span>


    <span class="k">return</span></div>

<span class="c1">##########################################################################################</span>
<span class="k">def</span> <span class="nf">build_hive</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">branches</span><span class="p">,</span><span class="n">connections</span><span class="p">,</span><span class="n">node_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">branch_extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">angle</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span><span class="n">branch_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">node_cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">,</span><span class="n">node_alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>\
               <span class="n">edge_cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">,</span><span class="n">edge_alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">edge_vrange</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">node_vrange</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">node_sizes</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>\
               <span class="n">branch_lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">edge_lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">radians</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">node_lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">nodes3d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">sphere_res</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>\
               <span class="n">lightsource</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">full3d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">viewpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ethresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">show_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    By default no threshold is applied to edges, i.e., even edges with zero-weights are drawn using </span>
<span class="sd">    the respective value from the colormap `edge_cmap`. If you want to remove zero-weight edges use </span>
<span class="sd">    the keyword argument `ethresh = 0`. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define some default values in case the user didn&#39;t provide all optional inputs</span>
    <span class="n">branch_beg</span> <span class="o">=</span> <span class="mf">0.05</span>                   <span class="c1"># Start of branches as displacement from `center` (if `branch_extent == None`)</span>
    <span class="n">branch_end</span> <span class="o">=</span> <span class="mf">0.95</span>                   <span class="c1"># Length of branches (if `branch_extent == None`)</span>
    <span class="n">pos_offset</span> <span class="o">=</span> <span class="mf">0.05</span>                   <span class="c1"># Offset percentage for nodes on branches (if `positions == None`)</span>
    <span class="n">x_offset</span>   <span class="o">=</span> <span class="mf">0.1</span>                    <span class="c1"># Offset percentage for x-axis limits</span>
    <span class="n">y_offset</span>   <span class="o">=</span> <span class="mf">0.1</span>                    <span class="c1"># Offset percentage for y-axis limits</span>
    <span class="n">z_offset</span>   <span class="o">=</span> <span class="mf">0.1</span>                    <span class="c1"># Offset percentage for z-axis limits (only relevant if `full3d == True`)</span>

    <span class="c1"># Error checking for dictionaries with numeric values</span>
    <span class="k">def</span> <span class="nf">check_dict</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">dct</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The provided &#39;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39; have to be a dictionary with the same keys as `branches`!&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">arrcheck</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided branches and &quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot; don&#39;t match up!&quot;</span><span class="p">)</span>

    <span class="c1"># Amend `FancyArrowPatch` by 3D capabilities </span>
    <span class="c1"># (taken from http://stackoverflow.com/questions/11140163/python-matplotlib-plotting-a-3d-cube-a-sphere-and-a-vector)</span>
    <span class="k">class</span> <span class="nc">Arrow3D</span><span class="p">(</span><span class="n">FancyArrowPatch</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">FancyArrowPatch</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verts3d</span> <span class="o">=</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span>

        <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
            <span class="n">xs3d</span><span class="p">,</span> <span class="n">ys3d</span><span class="p">,</span> <span class="n">zs3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts3d</span>
            <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span> <span class="o">=</span> <span class="n">proj3d</span><span class="o">.</span><span class="n">proj_transform</span><span class="p">(</span><span class="n">xs3d</span><span class="p">,</span> <span class="n">ys3d</span><span class="p">,</span> <span class="n">zs3d</span><span class="p">,</span> <span class="n">renderer</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_positions</span><span class="p">((</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">]),(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ys</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">FancyArrowPatch</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span>

    <span class="c1"># Check if `ax` is really an mpl axis object</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Could not make axis &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; active!&quot;</span><span class="p">)</span>

    <span class="c1"># See if `branches` is a dictionary of branch numbers/labels holding node-numbers </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The input `branches` has to be dictionary-like, not &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Branches must be provided as dictionary of node arrays/lists!!&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;node indices&#39;</span><span class="p">)</span>
    <span class="n">branch_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">num_branches</span> <span class="o">=</span> <span class="n">branch_arr</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">num_branches</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only one branch found - no bueno&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;OrderedDict&#39;</span><span class="p">:</span>
        <span class="n">branch_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">branch_arr</span><span class="p">)</span>                <span class="c1"># if we have a regular dict, sort its keys</span>
    <span class="n">node_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">node_arr</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">node_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">node_arr</span><span class="p">)</span>
    <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">node_arr</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">node_arr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">node_arr</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Node numbers have to be contiguous in ascending order starting with 0!&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">branches</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">br</span><span class="p">])</span>

    <span class="c1"># See if `connections` is a 2d array that matches the provided branch dictionary</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span><span class="s1">&#39;connections&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">connections</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">num_nodes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of nodes does not match connection matrix!&#39;</span><span class="p">)</span>

    <span class="c1"># Let&#39;s see if we&#39;re going to have fun in 3D</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes3d</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Three-dimensional nodes are activated using a binary True/False flag!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full3d</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Full 3D plotting is activated using a binary True/False flag!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
        <span class="n">nodes3d</span> <span class="o">=</span> <span class="kc">False</span>         <span class="c1"># just internally: turn off this switch to avoid confusion later on</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">show_grid</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Grid is drawn or not based on a binary True/False flag!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show_grid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">full3d</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;WARNING: 3D grid is only shown for full 3D plots!&quot;</span>

    <span class="c1"># Now check resolution parameter for rendering spheres</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">sphere_res</span><span class="p">,</span><span class="s1">&#39;sphere_res&#39;</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">sphere_res</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;WARNING: The resolution parameter for nodal spheres is very large - rendering might take forever...&quot;</span>

    <span class="c1"># See if a light-source for illumination was provided</span>
    <span class="k">if</span> <span class="n">lightsource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lightsource</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lightsource</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">lightsource</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">90</span><span class="p">,</span><span class="mi">45</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lightsource</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">lightsource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lightsource</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lightsource</span><span class="p">)</span>
            <span class="n">arrcheck</span><span class="p">(</span><span class="n">lightsource</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;lightsource&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lightsource</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">lightsource</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">360</span> <span class="ow">or</span> <span class="n">lightsource</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Light-source azimuth/elevation has to be between 0-360 and 0-90 degrees, respectively!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lightsource</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Light-source has to be provided as azimuth/altitude degrees!&quot;</span><span class="p">)</span>

    <span class="c1"># See if a threshold for drawing edges was provided, if not, don&#39;t use one</span>
    <span class="k">if</span> <span class="n">ethresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">ethresh</span><span class="p">,</span><span class="s1">&#39;ethresh&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># See if a camera position (in azimuth/elevation degrees) was provided, if not use some defaults</span>
    <span class="k">if</span> <span class="n">viewpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">viewpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">viewpoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">viewpoint</span><span class="p">):</span>
            <span class="n">arrcheck</span><span class="p">(</span><span class="n">viewpoint</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;viewpoint&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">viewpoint</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;View-point has to be provided as azimuth/altitude degrees!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;View-point for illumination has to [`azdeg`,`altdeg`]!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">viewpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">60</span><span class="p">,</span><span class="mi">30</span><span class="p">])</span>
        
    <span class="c1"># See if nodal values were provided, if not create simple dict</span>
    <span class="k">if</span> <span class="n">node_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check_dict</span><span class="p">(</span><span class="n">node_vals</span><span class="p">,</span><span class="s1">&#39;nodal values&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">node_vals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">vals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Nodal values must be between zero and one!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">node_vals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">branch</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node_vals</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># See if center makes sense, if provided</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported type for input `center`: &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="n">arrcheck</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">full3d</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">center</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Center coordinates have to be two-dimensional!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full3d</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">center</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For 3D plots center coordinates have to be three-dimensional!&quot;</span><span class="p">)</span>

    <span class="c1"># See if branch lengths were provided, otherwise construct&#39;em</span>
    <span class="k">if</span> <span class="n">branch_extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The provided branch dimensions have to be a dictionary with the same keys as `branches`!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arrcheck</span><span class="p">(</span><span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">],</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;branch dimensions&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only two values by branch supported for branch dimensions!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch dimensions have to be increasing (beginning -&gt; end)!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">branch_extent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_beg</span><span class="p">,</span><span class="n">branch_end</span><span class="p">]</span>

    <span class="c1"># See if nodal positions were provided, if not create simple dict</span>
    <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check_dict</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span><span class="s1">&#39;nodal positions&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">positions</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">positions</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Nodal positions on branches must be within branch extent!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">branch</span><span class="p">,</span> <span class="n">extent</span> <span class="ow">in</span> <span class="n">branch_extent</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">pos_offset</span><span class="o">*</span><span class="n">length</span>
            <span class="n">positions</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span><span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="c1"># See if labels were provided and make sense, otherwise don&#39;t use labels</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The provided nodal labels have to be a dictionary with the same keys as `branches`!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">labels</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided branches and nodal labels don&#39;t match up!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">branch</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The provided nodal labels must be strings!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full3d</span> <span class="ow">or</span> <span class="n">nodes3d</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;WARNING: Due to limiations in mplot3d the positiong of text in 3d space is somewhat screwed up...&quot;</span>

    <span class="c1"># Now make sure label font-size makes sense</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">labelsize</span><span class="p">,</span><span class="s1">&#39;labelsize&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

    <span class="c1"># Check branch angle(s) were provided, if not, generate&#39;em</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The provided branch angles have to be a dictionary with the same keys as `branches`!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
                <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
                <span class="n">arrcheck</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">],</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;3D branch angles&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;3D branch angles must be provided as two values per branch!&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">360</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Azimuth must be between 0 and 360 degrees!&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">90</span> <span class="ow">or</span> <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Elevation must be between -90 and +90 degrees!&quot;</span><span class="p">)</span>
                <span class="n">azim</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">elev</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">elev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">elev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">elev</span> <span class="o">+</span> <span class="p">(</span><span class="n">elev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elev</span><span class="p">)</span>
                <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">azim</span><span class="p">,</span><span class="n">elev</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Branch angles must be real-valued, one value per branch!&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch angles must not be NaN or Inf!&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">360</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch angles must be between 0 and 360 degrees!&quot;</span><span class="p">)</span>
                <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ange</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">360</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">angle</span><span class="p">[</span><span class="n">branch_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span> <span class="c1"># in spherical coordinates (main branch is vertical line from origin)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> 
            <span class="n">degs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">start</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">num_branches</span><span class="p">)</span>        <span class="c1"># these are the &quot;azimuth&quot; angles (well, not really...)</span>
            <span class="n">elev</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">for</span> <span class="n">br</span><span class="p">,</span> <span class="n">branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>         <span class="c1"># Here order is important! Use the generated (sorted) array!</span>
                <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">degs</span><span class="p">[</span><span class="n">br</span><span class="p">],</span><span class="n">elev</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">degs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="n">angle</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">num_branches</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">br</span><span class="p">,</span> <span class="n">branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_arr</span><span class="p">):</span>         <span class="c1"># Here order is important! Use the generated (sorted) array!</span>
                <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">degs</span><span class="p">[</span><span class="n">br</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Branch angles have to be provided either as scalar or dictionary!&quot;</span><span class="p">)</span>

    <span class="c1"># Check color-values of branches - if not provided, construct&#39;em</span>
    <span class="k">if</span> <span class="n">branch_colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branch_colors</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_colors</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one color per branch is supported!&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">branch_colors</span><span class="p">[</span><span class="n">branch</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The provided branch colors must be strings!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branch_colors</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="n">branch_colors</span>
            <span class="n">branch_colors</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">branch_colors</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The provided branch colors have to be either a string or &quot;</span><span class="o">+</span>\
                            <span class="s2">&quot;a dictionary with the same keys as `branches`!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">branch_colors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">branch_colors</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Black&#39;</span>

    <span class="c1"># Check node and edge color maps</span>
    <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node_cmap</span><span class="p">,</span><span class="n">edge_cmap</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Colormap&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Node/Edge colormaps have to be matplotlib colormaps!&quot;</span><span class="p">)</span>

    <span class="c1"># Check value ranges for nodes and edges</span>
    <span class="k">for</span> <span class="n">vrange</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node_vrange</span><span class="p">,</span><span class="n">edge_vrange</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">vrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vrange</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported type for node/edge value ranges: &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">vrange</span><span class="p">,</span><span class="s1">&#39;vector&#39;</span><span class="p">,</span><span class="s1">&#39;node/edge value range&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">vrange</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node/Edge value range has to be two-dimensional!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node/Edge value range must strictly increasing!&quot;</span><span class="p">)</span>

    <span class="c1"># See if nodal sizes have been provided, if not construct dictionary </span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_sizes</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="n">check_dict</span><span class="p">(</span><span class="n">node_sizes</span><span class="p">,</span><span class="s1">&#39;nodal sizes&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">node_sizes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nodal sizes have to be non-negative!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">node_sizes</span><span class="p">):</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">node_sizes</span><span class="p">,</span><span class="s1">&#39;node_sizes&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">node_sizes</span>
        <span class="n">node_sizes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">branch</span><span class="p">,</span><span class="n">nodes</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node_sizes</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Nodal sizes have to be provided either as scalar or dictionary!&quot;</span><span class="p">)</span>

    <span class="c1"># See if nodal alpha values have been provided, if not construct dictionary </span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_alpha</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="n">check_dict</span><span class="p">(</span><span class="n">node_alpha</span><span class="p">,</span><span class="s1">&#39;nodal alpha values&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">node_alpha</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">vals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nodal alpha values have to be between zero and one!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">node_alpha</span><span class="p">):</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">node_alpha</span><span class="p">,</span><span class="s1">&#39;node_alpha&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">node_alpha</span>
        <span class="n">node_alpha</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">branch</span><span class="p">,</span><span class="n">nodes</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Nodal alpha values have to be provided either as scalar or dictionary!&quot;</span><span class="p">)</span>

    <span class="c1"># Now make sure node line-width makes sense</span>
    <span class="n">scalarcheck</span><span class="p">(</span><span class="n">node_lw</span><span class="p">,</span><span class="s1">&#39;node_lw&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;WARNING: Line-width specifications for nodes is ignored for full 3D plots!&quot;</span>

    <span class="c1"># Check if line-widths for branches have been provided, otherwise assign default values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branch_lw</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branch_lw</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The provided branch line-widths have to be a dictionary with the same keys as `branches`!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">branch_lw</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">branch_lw</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch line-widths must be real-valued, one value per branch!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">branch_lw</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch line-widths must not be NaN or Inf!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">branch_lw</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch line-widths have to be non-negative!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">branch_lw</span><span class="p">):</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">branch_lw</span><span class="p">,</span><span class="s1">&#39;branch_lw&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="n">branch_lw</span>
        <span class="n">branch_lw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">branch_lw</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">bw</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Branch line-widths have to be provided either as scalar or dictionary!&quot;</span><span class="p">)</span>

    <span class="c1"># Check if alpha-values for branches have been provided, otherwise assign default values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branch_alpha</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branch_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The provided branch alpha values have to be a dictionary with the same keys as `branches`!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">branch_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">branch_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch alpha values must be real-valued, one value per branch!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">branch_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch alpha values must not be NaN or Inf!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">branch_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">branch_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branch alpha values must be between zero and one!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">branch_alpha</span><span class="p">):</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">branch_alpha</span><span class="p">,</span><span class="s1">&#39;branch_alpha&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="n">branch_alpha</span>
        <span class="n">branch_alpha</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">branch_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">bw</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Branch alpha values have to be provided either as scalar or dictionary!&quot;</span><span class="p">)</span>

    <span class="c1"># Check if line-widths for edges have been provided, otherwise assign default values</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">edge_lw</span><span class="p">):</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">edge_lw</span><span class="p">,</span><span class="s1">&#39;edge_lw&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="n">edge_lw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">connections</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">edge_lw</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">edge_lw</span><span class="p">,</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span><span class="s1">&#39;edge_lw&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">edge_lw</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">connections</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge line-widths have to be provided in the same format as connection array!&quot;</span><span class="p">)</span>

    <span class="c1"># Check if alpha values for edges have been provided, otherwise assign default values</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">edge_alpha</span><span class="p">):</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">edge_alpha</span><span class="p">,</span><span class="s1">&#39;edge_alpha&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">edge_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">connections</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">edge_alpha</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">edge_alpha</span><span class="p">,</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span><span class="s1">&#39;edge_alpha&#39;</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">edge_alpha</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">connections</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge alpha values have to be provided in the same format as connection array!&quot;</span><span class="p">)</span>

    <span class="c1"># Check if an intial setting for the arch radian was provided, otherwise use the default</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">radians</span><span class="p">):</span>
        <span class="n">scalarcheck</span><span class="p">(</span><span class="n">radians</span><span class="p">,</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrcheck</span><span class="p">(</span><span class="n">radians</span><span class="p">,</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rsh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">num_branches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arch radians must be provided as square array matching no. of branches!!&quot;</span><span class="p">)</span>

    <span class="c1"># Prepare axis</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># If nodes have to be rendered as spheres, some tuning is required...</span>
    <span class="k">if</span> <span class="n">nodes3d</span> <span class="ow">or</span> <span class="n">full3d</span><span class="p">:</span>

        <span class="c1"># Turn on 3d projection if nodes are to be rendered as spheres</span>
        <span class="n">bgcol</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_axis_bgcolor</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span><span class="n">axisbg</span><span class="o">=</span><span class="n">bgcol</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">full3d</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">,</span><span class="n">elev</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">azim</span><span class="o">=</span><span class="n">viewpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elev</span><span class="o">=</span><span class="n">viewpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Turn off 3D grid and change background of panes (or not)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">show_grid</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">w_xaxis</span><span class="o">.</span><span class="n">set_pane_color</span><span class="p">(</span><span class="n">colorConverter</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">bgcol</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">w_yaxis</span><span class="o">.</span><span class="n">set_pane_color</span><span class="p">(</span><span class="n">colorConverter</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">bgcol</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">w_zaxis</span><span class="o">.</span><span class="n">set_pane_color</span><span class="p">(</span><span class="n">colorConverter</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">bgcol</span><span class="p">))</span>

        <span class="c1"># Turn off all axes highlights</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="o">.</span><span class="n">line</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">line</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">line</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="c1"># Generate surface data for the prototype nodal sphere</span>
        <span class="n">theta</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">sphere_res</span><span class="p">,</span><span class="n">sphere_res</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">sphere_res</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">phi</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">sphere_res</span><span class="p">,</span><span class="n">sphere_res</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">sphere_res</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cosphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span> <span class="n">cosphi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cosphi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sinth</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span> <span class="n">sinth</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sinth</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>    
        <span class="n">xsurf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">cosphi</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
        <span class="n">ysurf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">cosphi</span><span class="p">,</span><span class="n">sinth</span><span class="p">)</span>
        <span class="n">zsurf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">sphere_res</span><span class="o">+</span><span class="mi">1</span><span class="p">,)))</span>
        
        <span class="c1"># If virtual lighting is wanted, create a light source for illumination</span>
        <span class="k">if</span> <span class="n">lightsource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">light</span>   <span class="o">=</span> <span class="n">LightSource</span><span class="p">(</span><span class="o">*</span><span class="n">lightsource</span><span class="p">)</span>
            <span class="n">rgb_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">zsurf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">zsurf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Start by truncating color-values based on vrange limits that were provided</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node_vrange</span><span class="p">):</span>
        <span class="n">node_cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">Normalize</span><span class="p">(</span><span class="n">node_vrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">node_vrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">cmap</span><span class="o">=</span><span class="n">node_cmap</span><span class="p">)</span><span class="o">.</span><span class="n">to_rgba</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">edge_vrange</span><span class="p">):</span>
        <span class="n">edge_cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">Normalize</span><span class="p">(</span><span class="n">edge_vrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">edge_vrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">cmap</span><span class="o">=</span><span class="n">edge_cmap</span><span class="p">)</span><span class="o">.</span><span class="n">to_rgba</span>

    <span class="c1"># Plot branches and construct nodal patches (we do this no matter if we&#39;re 3-dimensional or not)</span>
    <span class="n">node_patches</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">branch_dvecs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">branch_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lw&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,)),</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;zorder&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branch_arr</span><span class="p">:</span>

        <span class="c1"># Compute normed directional vector of branch</span>
        <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
            <span class="n">azim</span><span class="p">,</span><span class="n">elev</span> <span class="o">=</span> <span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span>
            <span class="n">bdry</span> <span class="o">=</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">elev</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azim</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">elev</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azim</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">elev</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bdry</span> <span class="o">=</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="n">branch</span><span class="p">])])</span>
        <span class="n">vec</span>  <span class="o">=</span> <span class="n">bdry</span> <span class="o">-</span> <span class="n">center</span>
        <span class="n">vec</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="n">bstart</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span>
        <span class="n">branch_dvecs</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span>

        <span class="c1"># Plot branch as straight line</span>
        <span class="n">branch_kwargs</span><span class="p">[</span><span class="s1">&#39;lw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_lw</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span>
        <span class="n">branch_kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_colors</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span>
        <span class="n">branch_kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">bstart</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bdry</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">bstart</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bdry</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">zs</span><span class="o">=</span><span class="p">[</span><span class="n">bstart</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bdry</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">zdir</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">branch_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nodes3d</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">bstart</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bdry</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">bstart</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bdry</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">zs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">zdir</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">branch_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">bstart</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bdry</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">bstart</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bdry</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="o">**</span><span class="n">branch_kwargs</span><span class="p">)</span>

        <span class="c1"># Now construct circular patches for all nodes and save&#39;em in the `patch_list` list (and the `node_patch` dict)</span>
        <span class="n">patch_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="n">vec</span><span class="o">*</span><span class="n">positions</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">]</span>
            <span class="n">patch_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Circle</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="n">node_sizes</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">],</span>\
                                     <span class="n">facecolor</span><span class="o">=</span><span class="n">node_cmap</span><span class="p">(</span><span class="n">node_vals</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">]),</span>\
                                     <span class="n">alpha</span><span class="o">=</span><span class="n">node_alpha</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">],</span>\
                                     <span class="n">lw</span><span class="o">=</span><span class="n">node_lw</span><span class="p">,</span>\
                                     <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch_list</span>

    <span class="c1"># Determine if our network is directed or not</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">issym</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span>

    <span class="c1"># Allocate dicionary for all edge-related parameters</span>
    <span class="n">edge_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;connectionstyle&#39;</span><span class="p">:</span><span class="s1">&#39;a string&#39;</span><span class="p">,</span><span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,)),</span> <span class="s1">&#39;zorder&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">sym</span><span class="p">:</span>
        <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;arrowstyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;arrowstyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-|&gt;&#39;</span>

    <span class="c1"># 3D is again the special snowflake, so do this nonsense separately...</span>
    <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>

        <span class="c1"># In a fully three-dimensional environment, we can&#39;t go &#39;round the tree to plot edges - everything may be connected</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">br</span><span class="p">,</span> <span class="n">branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_arr</span><span class="p">):</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">branch_arr</span><span class="p">,</span><span class="n">seen</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">twig</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">radians</span><span class="p">):</span>
                    <span class="n">br_vec</span> <span class="o">=</span> <span class="n">branch_dvecs</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span>
                    <span class="n">tw_vec</span> <span class="o">=</span> <span class="n">branch_dvecs</span><span class="p">[</span><span class="n">twig</span><span class="p">]</span>
                    <span class="n">ang_bt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">br_vec</span><span class="p">,</span><span class="n">tw_vec</span><span class="p">)),</span><span class="n">br_vec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tw_vec</span><span class="p">))</span>
                    <span class="n">ang_bt</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">ang_bt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">rad</span>    <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">ang_bt</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">radians</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rad</span> <span class="o">=</span> <span class="n">radians</span><span class="p">[</span><span class="n">br</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">branch_arr</span><span class="o">==</span><span class="n">twig</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">node1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">n2</span><span class="p">,</span><span class="n">node2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">twig</span><span class="p">]):</span>
                        <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;connectionstyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;arc3,rad=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">rad</span>
                        <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;lw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_lw</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">]</span>
                        <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_alpha</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">]</span>
                        <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_cmap</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">])</span>
                        <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">node_patches</span><span class="p">[</span><span class="n">twig</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">node_patches</span><span class="p">[</span><span class="n">twig</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="n">zcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">node_patches</span><span class="p">[</span><span class="n">twig</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">sym</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">connections</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ethresh</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">Arrow3D</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">zcoords</span><span class="p">,</span><span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">connections</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ethresh</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">Arrow3D</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">zcoords</span><span class="p">,</span><span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">connections</span><span class="p">[</span><span class="n">node2</span><span class="p">,</span><span class="n">node1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ethresh</span><span class="p">:</span>
                                <span class="n">rad</span> <span class="o">=</span> <span class="o">-</span> <span class="n">rad</span>
                                <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;connectionstyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;arc3,rad=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">rad</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">Arrow3D</span><span class="p">(</span><span class="n">xcoords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">ycoords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">zcoords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>

    <span class="c1"># 2D rendering of edges is a lot easier (just go branch by branch)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">br</span><span class="p">,</span> <span class="n">branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_arr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">br</span> <span class="o">&lt;</span> <span class="n">branch_arr</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">twig</span> <span class="o">=</span> <span class="n">branch_arr</span><span class="p">[</span><span class="n">br</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">twig</span> <span class="o">=</span> <span class="n">branch_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">radians</span><span class="p">):</span>
                <span class="n">br_vec</span> <span class="o">=</span> <span class="n">branch_dvecs</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span>
                <span class="n">tw_vec</span> <span class="o">=</span> <span class="n">branch_dvecs</span><span class="p">[</span><span class="n">twig</span><span class="p">]</span>
                <span class="n">ang_bt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">tw_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">tw_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">br_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">br_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ang_bt</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">ang_bt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">rad</span>    <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">ang_bt</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">radians</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="n">radians</span><span class="p">[</span><span class="n">br</span><span class="p">,</span><span class="n">br</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">node1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">n2</span><span class="p">,</span><span class="n">node2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">twig</span><span class="p">]):</span>
                    <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;connectionstyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;arc3,rad=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">rad</span>
                    <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;lw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_lw</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">]</span>
                    <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_alpha</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">]</span>
                    <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_cmap</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">])</span>
                    <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">node_patches</span><span class="p">[</span><span class="n">twig</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">node_patches</span><span class="p">[</span><span class="n">twig</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">sym</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">connections</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ethresh</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nodes3d</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">Arrow3D</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">FancyArrowPatch</span><span class="p">(</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>\
                                                             <span class="n">node_patches</span><span class="p">[</span><span class="n">twig</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>\
                                                             <span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">connections</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ethresh</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nodes3d</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">Arrow3D</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">FancyArrowPatch</span><span class="p">(</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>\
                                                             <span class="n">node_patches</span><span class="p">[</span><span class="n">twig</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>\
                                                             <span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">connections</span><span class="p">[</span><span class="n">node2</span><span class="p">,</span><span class="n">node1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ethresh</span><span class="p">:</span>
                            <span class="n">rad</span> <span class="o">=</span> <span class="o">-</span> <span class="n">rad</span>
                            <span class="n">edge_kwargs</span><span class="p">[</span><span class="s1">&#39;connectionstyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;arc3,rad=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">rad</span>
                            <span class="k">if</span> <span class="n">nodes3d</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">Arrow3D</span><span class="p">(</span><span class="n">xcoords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">ycoords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">FancyArrowPatch</span><span class="p">(</span><span class="n">node_patches</span><span class="p">[</span><span class="n">twig</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>\
                                                             <span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>\
                                                             <span class="o">**</span><span class="n">edge_kwargs</span><span class="p">))</span>

    <span class="c1"># Finally, draw nodes and compute maximal extent of branches</span>
    <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> 
    <span class="n">bot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> 
    <span class="n">lft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> 
    <span class="n">rgt</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">up</span>  <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">lo</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">lbl_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="n">labelsize</span><span class="p">,</span><span class="s1">&#39;ha&#39;</span><span class="p">:</span><span class="s1">&#39;center&#39;</span><span class="p">,</span><span class="s1">&#39;va&#39;</span><span class="p">:</span><span class="s1">&#39;center&#39;</span><span class="p">}</span>
    <span class="n">nd_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cstride&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;rstride&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;antialiased&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;zorder&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">zcord</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branch_arr</span><span class="p">:</span>
        <span class="n">branch_tvec</span> <span class="o">=</span> <span class="n">branch_extent</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">branch_dvecs</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">top</span><span class="p">,</span><span class="n">branch_tvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">bot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">bot</span><span class="p">,</span><span class="n">branch_tvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">lft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">lft</span><span class="p">,</span><span class="n">branch_tvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">rgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">rgt</span><span class="p">,</span><span class="n">branch_tvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">up</span><span class="p">,</span><span class="n">branch_tvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">lo</span><span class="p">,</span><span class="n">branch_tvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nodes3d</span> <span class="ow">or</span> <span class="n">full3d</span><span class="p">:</span>
                <span class="n">circ</span> <span class="o">=</span> <span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
                    <span class="n">zcord</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">nd_kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">()</span>
                <span class="n">nd_kwargs</span><span class="p">[</span><span class="s1">&#39;zorder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">get_zorder</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">lightsource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nd_kwargs</span><span class="p">[</span><span class="s1">&#39;facecolors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">light</span><span class="o">.</span><span class="n">shade_rgb</span><span class="p">(</span><span class="n">rgb_arr</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">zsurf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nd_kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_radius</span><span class="p">()</span><span class="o">*</span><span class="n">xsurf</span> <span class="o">+</span> <span class="n">circ</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                                <span class="n">circ</span><span class="o">.</span><span class="n">get_radius</span><span class="p">()</span><span class="o">*</span><span class="n">ysurf</span> <span class="o">+</span> <span class="n">circ</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
                                <span class="n">circ</span><span class="o">.</span><span class="n">get_radius</span><span class="p">()</span><span class="o">*</span><span class="n">zsurf</span> <span class="o">+</span> <span class="n">zcord</span><span class="p">,</span>\
                                <span class="o">**</span><span class="n">nd_kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nodes3d</span><span class="p">:</span>
                        <span class="n">lcord</span> <span class="o">=</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">circ</span><span class="o">.</span><span class="n">get_radius</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lcord</span> <span class="o">=</span> <span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                            <span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
                            <span class="n">lcord</span><span class="p">,</span>\
                            <span class="n">labels</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">],</span><span class="o">**</span><span class="n">lbl_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                            <span class="n">node_patches</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
                            <span class="n">labels</span><span class="p">[</span><span class="n">branch</span><span class="p">][</span><span class="n">node</span><span class="p">],</span><span class="o">**</span><span class="n">lbl_kwargs</span><span class="p">)</span>

    <span class="c1"># Set axes limits based on extent of branches</span>
    <span class="n">x_width</span> <span class="o">=</span> <span class="n">rgt</span> <span class="o">-</span> <span class="n">lft</span>
    <span class="n">y_heght</span> <span class="o">=</span> <span class="n">top</span> <span class="o">-</span> <span class="n">bot</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">lft</span><span class="o">-</span><span class="n">x_offset</span><span class="o">*</span><span class="n">x_width</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="n">rgt</span><span class="o">+</span><span class="n">x_offset</span><span class="o">*</span><span class="n">x_width</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">bot</span><span class="o">-</span><span class="n">y_offset</span><span class="o">*</span><span class="n">y_heght</span><span class="p">,</span><span class="n">top</span><span class="o">=</span><span class="n">top</span><span class="o">+</span><span class="n">y_offset</span><span class="o">*</span><span class="n">y_heght</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">full3d</span><span class="p">:</span>
        <span class="n">z_len</span> <span class="o">=</span> <span class="n">up</span> <span class="o">-</span> <span class="n">lo</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">lo</span><span class="o">-</span><span class="n">z_offset</span><span class="o">*</span><span class="n">z_len</span><span class="p">,</span><span class="n">top</span><span class="o">=</span><span class="n">up</span><span class="o">+</span><span class="n">z_offset</span><span class="o">*</span><span class="n">z_len</span><span class="p">)</span>

    <span class="c1"># Draw the beauty and get the hell out of here</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">full3d</span> <span class="ow">or</span> <span class="n">nodes3d</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

<span class="c1">##########################################################################################</span>
<div class="viewcode-block" id="nw_zip"><a class="viewcode-back" href="../_stubs/nws_tools.nw_zip.html#nws_tools.nw_zip">[docs]</a><span class="k">def</span> <span class="nf">nw_zip</span><span class="p">(</span><span class="n">ntw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the upper triangular portion of a real symmetric matrix to a vector and vice versa</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ntw : NumPy 1d/2d/3d array</span>
<span class="sd">        Array representing either (a) a vector (1d array) or (b) a set of vectors (2d array) </span>
<span class="sd">        holding the upper triangular part of a symmetric matrix in column-wise order or</span>
<span class="sd">        (c) a matrix (2d array) or (d) a rank 3 tensor comprising a cohort of symmetric </span>
<span class="sd">        matrices whose upper triangular entries will be extracted. </span>
<span class="sd">        If `ntw` is a 2d array, it may either represent a symmetric matrix for compression </span>
<span class="sd">        or an array of column vectors. Specifically, a `K` by `M` array will be reconstructed</span>
<span class="sd">        to form a `N`-by-`N`-by`M` array of symmetric `N`-by-`N` matrices, where</span>
<span class="sd">        `K = N * (N - 1) / 2`. Conversely, if the input is a 3d-array, its format is </span>
<span class="sd">        assumed to be `N`-by-`N`-by-`M`. See Notes below for details. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nws : NumPy 1d/2d/3d array</span>
<span class="sd">        Depending on the input, the returned array is either a compressed representation of </span>
<span class="sd">        the symmetric input matrix/matrices or a full matrix/tensor reconstructed from </span>
<span class="sd">        the provided upper triangular values. </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note, that this routine does NOT consider diagonal elements, i.e., only off-diagonal </span>
<span class="sd">    entries will be stored/reconstructed. By design, entries are assumed to be ordered</span>
<span class="sd">    column-wise. Note further, that a symmetric `N`-by-`N` matrix contains `K = N * (N - 1) / 2`</span>
<span class="sd">    upper triangular elements. Thus, if `N = 3` then `K = 3` so that any symmetric 3-by-3 </span>
<span class="sd">    array can either represent a symmetric matrix or a set of three 3-element vectors</span>
<span class="sd">    representing upper triangular entries of three different symmetric matrices. In this case, </span>
<span class="sd">    the routine always assumes that the input represents a symmetric matrix and </span>
<span class="sd">    prints a warning message. </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider the symmetric matrix `mat`</span>

<span class="sd">    &gt;&gt;&gt; mat </span>
<span class="sd">    array([[ 0.,  1.,  2.,  3.],</span>
<span class="sd">           [ 1.,  0.,  4.,  5.],</span>
<span class="sd">           [ 2.,  4.,  0.,  6.],</span>
<span class="sd">           [ 3.,  5.,  6.,  0.]])</span>

<span class="sd">    Using `nw_zip` to compress `mat` yields the array `vec`</span>

<span class="sd">    &gt;&gt;&gt; import nws_tools as nwt</span>
<span class="sd">    &gt;&gt;&gt; vec = nwt.nw_zip(mat)</span>
<span class="sd">    &gt;&gt;&gt; vec</span>
<span class="sd">    array([ 1.,  2.,  3.,  4.,  5.,  6.])</span>

<span class="sd">    Now reconstruct `mat` from `vec`</span>

<span class="sd">    &gt;&gt;&gt; nwt.nw_zip(vec)</span>
<span class="sd">    array([[ 0.,  1.,  2.,  3.],</span>
<span class="sd">           [ 1.,  0.,  4.,  5.],</span>
<span class="sd">           [ 2.,  4.,  0.,  6.],</span>
<span class="sd">           [ 3.,  5.,  6.,  0.]])</span>
<span class="sd">    </span>
<span class="sd">    Consider a second symmetric matrix `mat2`</span>

<span class="sd">    &gt;&gt;&gt; mat2</span>
<span class="sd">    array([[  0.,   7.,   8.,   9.],</span>
<span class="sd">           [  7.,   0.,  10.,  11.],</span>
<span class="sd">           [  8.,  10.,   0.,  12.],</span>
<span class="sd">           [  9.,  11.,  12.,   0.]])</span>

<span class="sd">    Now, collect `mat` and `mat2` in a tensor and use `nw_zip` to compress it</span>

<span class="sd">    &gt;&gt;&gt; mats = np.zeros((4,4,2))</span>
<span class="sd">    &gt;&gt;&gt; mats[:,:,0] = mat</span>
<span class="sd">    &gt;&gt;&gt; mats[:,:,1] = mat2</span>
<span class="sd">    &gt;&gt;&gt; vecs = nw_zip(mats)</span>
<span class="sd">    &gt;&gt;&gt; vecs</span>
<span class="sd">    array([[  1.,   7.],</span>
<span class="sd">           [  2.,   8.],</span>
<span class="sd">           [  3.,   9.],</span>
<span class="sd">           [  4.,  10.],</span>
<span class="sd">           [  5.,  11.],</span>
<span class="sd">           [  6.,  12.]])</span>

<span class="sd">    Uncompressing `vecs` yields `mats` again</span>

<span class="sd">    &gt;&gt;&gt; (mats == nw_zip(vecs)).min()</span>
<span class="sd">    True</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    -------- </span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity checks (we can&#39;t use `arrcheck` here, because `ntw` can have varying funky dimensions...)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stw</span> <span class="o">=</span> <span class="n">ntw</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input network must be a NumPy array, not &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">ntw</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input network must not have more than 3 dimensions!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">ntw</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">ntw</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input network must be a real-valued NumPy array!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ntw</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input network must be a real valued NumPy array without Infs or NaNs!&#39;</span><span class="p">)</span>
    
    <span class="c1"># If we&#39;re dealing with a 1d-array, convert it to a `K`-by-1 array to hit two birds with one stone below</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ntw</span> <span class="o">=</span> <span class="n">ntw</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ntw</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">stw</span> <span class="o">=</span> <span class="n">ntw</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Now let&#39;s do what we&#39;re here for: everything below assumes `N` is the dimension of the</span>
    <span class="c1"># considered symmetric matrix and `K` denotes the number of elements in its upper triangular</span>
    <span class="c1"># portion (excluding the main diagonal), i.e., `K = N * (N-1) / 2`</span>
    <span class="c1"># Start with the ambiguous case: input can be a single vector, an array of vectors or a connectivity matrix</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

        <span class="c1"># Input is square so it&#39;s a symmetric matrix. It&#39;s only ambiguous in case `N = 3` (then `K == N`),</span>
        <span class="c1"># but why would you go through all this trouble for a 3-by-3 matrix???</span>
        <span class="k">if</span> <span class="n">stw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">stw</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">issym</span><span class="p">(</span><span class="n">ntw</span><span class="p">):</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">stw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s2">&quot;WARNING: Assuming input array is a symmetric 3-by-3 matrix...&quot;</span>
                <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ntw</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input matrix is not symmetric and thus cannot be compressed!&quot;</span><span class="p">)</span>

        <span class="c1"># Input is an array of `M` vectors of length `K` each holding the entries of a symmetric `N`-by-`N` matrix</span>
        <span class="c1"># (note that `M = 1` is possible as well)</span>
        <span class="k">else</span><span class="p">:</span>
            
            <span class="c1"># First step: compute the original dimension `N` of the symmetric matrix by solving the</span>
            <span class="c1"># quadratic equation `N*(N-1)/2 = K`, where `K` is the length of the given input vector(s).</span>
            <span class="c1"># We&#39;re only interested in the positive solution here. To account for roundoff errors,</span>
            <span class="c1"># use `np.round`, but double-check the result</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">stw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">stw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">N</span><span class="o">*</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">!=</span> <span class="n">K</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided values cannot be arranged in a triangular layout!&quot;</span><span class="p">)</span>
            <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">nw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
            <span class="n">nws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                <span class="n">nw</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">nw</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntw</span><span class="p">[:,</span><span class="n">m</span><span class="p">]</span>
                <span class="n">nw</span> <span class="o">+=</span> <span class="n">nw</span><span class="o">.</span><span class="n">T</span>
                <span class="n">nws</span><span class="p">[:,:,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">nws</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>        <span class="c1"># If `M = 1` don&#39;t return a `N`-by-`N`-by-1 array</span>

    <span class="c1"># The input is a rank 3 tensor of dimension `(N,N,M)` holding `M` symmetric `N`-by-`N` matrices</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># No ambiguity here...</span>
        <span class="k">if</span> <span class="n">stw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">stw</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;First and second dimension of input tensor must be identical!&quot;</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">stw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">stw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">msk</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span><span class="n">M</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">nw</span> <span class="o">=</span> <span class="n">ntw</span><span class="p">[:,:,</span><span class="n">m</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">issym</span><span class="p">(</span><span class="n">nw</span><span class="p">):</span>
                <span class="n">nws</span><span class="p">[:,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">nw</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input matrix no. &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is not symmetric!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nws</span></div>

<span class="c1">##########################################################################################</span>
<span class="k">def</span> <span class="nf">arrcheck</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">kind</span><span class="p">,</span><span class="n">varname</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Local helper function performing sanity checks on arrays (1d/2d/3d)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sha</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a NumPy array, not &#39;</span><span class="o">+</span><span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;tensor&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sha</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a `N`-by-`N`-by-`k` NumPy array&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">sha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">sha</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a `N`-by-`N`-by-`k` NumPy array!&#39;</span><span class="p">)</span>
        <span class="n">dim_msg</span> <span class="o">=</span> <span class="s1">&#39;`N`-by-`N`-by-`k`&#39;</span>
    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;matrix&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sha</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a `N`-by-`N` NumPy array&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sha</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">sha</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a `N`-by-`N` NumPy array!&#39;</span><span class="p">)</span>
        <span class="n">dim_msg</span> <span class="o">=</span> <span class="s1">&#39;`N`-by-`N`&#39;</span>
    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;vector&#39;</span><span class="p">:</span>
        <span class="n">sha</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sha</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a NumPy 1darray&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">sha</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a NumPy 1darray of length `N`!&#39;</span><span class="p">)</span>
        <span class="n">dim_msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;Error checking could not be performed - something&#39;s wrong here...&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a real-valued &#39;</span><span class="o">+</span><span class="n">dim_msg</span><span class="o">+</span><span class="s1">&#39; NumPy array!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input `&#39;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s1">&#39;` must be a real valued NumPy array without Infs or NaNs!&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values of input array `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be between &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span>\
                             <span class="s2">&quot; and &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;!&quot;</span><span class="p">)</span>

<span class="c1">##########################################################################################</span>
<span class="k">def</span> <span class="nf">scalarcheck</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">varname</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Local helper function performing sanity checks on scalars</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">plt</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be a real scalar!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be finite!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be an integer!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input scalar `&quot;</span><span class="o">+</span><span class="n">varname</span><span class="o">+</span><span class="s2">&quot;` must be between &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; and &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;!&quot;</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>